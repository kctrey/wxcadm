<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>wxcadm API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wxcadm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json.decoder
import time
import requests
import logging
import base64
from exceptions import (OrgError, LicenseError, APIError, TokenError, PutError, XSIError)

# TODO: Eventually I would like to use dataclasses, but it will be a heavy lift, and doesn&#39;t save that much code

# TODO: There is a package-wide problem where we have Webex-native data and instance attributes that we write
#       to make the instances easier to work with. I have kept the native data because it is easier to push back
#       to Webex and safer in case the API changes. Ideally, we should store all attributes in ways that a user
#       would want them and pack them back into JSON as needed. In the meantime, like in the CallQueues object
#       I end up with the same values in multiple attributes, which is a bad idea.

# Set up logging
logging.basicConfig(level=logging.INFO,
                      filename=&#34;wxcadm.log&#34;,
                      format=&#39;%(asctime)s %(module)s:%(levelname)s:%(message)s&#39;)
# Some functions available to all classes and instances (optionally)
# TODO Lots of stuff probably could be moved here since there are common functions in most classes
_url_base = &#34;https://webexapis.com/&#34;


class Webex:
    # TODO List
    #    Add token refresh, just for completeness. For now, we don&#39;t mess with tokens at all.
    &#34;&#34;&#34;The base class for working with wxcadm.

    &#34;&#34;&#34;

    def __init__(self,
                 access_token: str,
                 create_org: bool = True,
                 get_people: bool = True,
                 get_locations: bool = True,
                 get_xsi: bool = False,
                 get_hunt_groups: bool = False,
                 get_call_queues: bool = False
                 ) -&gt; None:
        &#34;&#34;&#34;Initialize a Webex instance to communicate with Webex and store data

        Args:
            access_token (str): The Webex API Access Token to authenticate the API calls
            create_org (bool, optional): Whether to create an Org instance for all organizations.
            get_people (bool, optional): Whether to get all of the People and created instances for them
            get_locations (bool, optional): Whether to get all Locations and create instances for them
            get_xsi (bool, optional): Whether to get the XSI endpoints for each Org. Defaults to False, since
                not every Org has XSI capability
            get_hunt_groups (bool, optional): Whether to get the Hunt Groups for each Org. Defaults to False.
            get_call_queues (bool, optional): Whether to get the Call Queues for each Org. Defaults to False.

        Returns:
            Webex: The Webex instance

        &#34;&#34;&#34;
        logging.info(&#34;Webex instance initialized&#34;)
        # The access token is the only thing that we need to get started
        self._access_token: str = access_token
        # The Authorization header is going to be used by every API call in the package.
        # Might want to make it something global so we don&#39;t have to inherit it across all of the children
        self._headers: dict = {&#34;Authorization&#34;: &#34;Bearer &#34; + access_token}
        logging.debug(f&#34;Setting Org._headers to {self._headers}&#34;)

        # Instance attrs
        self.orgs: list[Org] = []
        &#39;&#39;&#39;A list of the Org instances that this Webex instance can manage&#39;&#39;&#39;
        # Get the orgs that this token can manage
        logging.debug(f&#34;Making API call to v1/organizations&#34;)
        r = requests.get(_url_base + &#34;v1/organizations&#34;, headers=self._headers)
        # Handle an invalid access token
        if r.status_code != 200:
            raise TokenError(&#34;The Access Token was not accepted by Webex&#34;)
        response = r.json()
        # Handle when no Orgs are returned. This is pretty rare
        if len(response[&#39;items&#39;]) == 0:
            raise OrgError
        # If a token can manage a lot of orgs, you might not want to create them all, because
        # it can take some time to do all of the API calls and get the data back
        if not create_org:
            logging.info(&#34;Org initialization not requested. Storing orgs.&#34;)
            self.orgs = response[&#39;items&#39;]
            return
        else:
            logging.info(&#34;Org initialization requested. Collecting orgs&#34;)
            for org in response[&#39;items&#39;]:
                # This builds an Org instance for every Org, so be careful
                # if the user manages multiple orgs
                logging.debug(f&#34;Processing org: {org[&#39;displayName&#39;]}&#34;)
                org = Org(org[&#39;displayName&#39;], org[&#39;id&#39;],
                          people=get_people, locations=get_locations, xsi=get_xsi, parent=self,
                          call_queues=get_call_queues, hunt_groups=get_hunt_groups)
                self.orgs.append(org)
            # Most users have only one org, so to make that easier for them to work with
            # we are also going to put the orgs[0] instance in the org attr
            # That way both .org and .orgs[0] are the same
            if len(self.orgs) == 1:
                logging.debug(f&#34;Only one org found. Storing as Webex.org&#34;)
                self.org = self.orgs[0]

    @property
    def headers(self):
        &#34;&#34;&#34;The &#34;universal&#34; HTTP headers with the Authorization header present&#34;&#34;&#34;
        return self._headers

    def get_org_by_name(self, name: str):
        &#34;&#34;&#34;Get the Org instance that matches all or part of the name argument.

        Args:
            name (str): Text to match against the Org name

        Returns:
            Org: The Org instance of the matching Org

        Raises:
            KeyError: Raised when no match is made

        &#34;&#34;&#34;
        for org in self.orgs:
            if name in org.name:
                return org
        raise KeyError(&#34;Org not found&#34;)


class Org(Webex):
    def __init__(self,
                 name: str,
                 id: str,
                 parent: Webex = None,
                 people: bool = True,
                 locations: bool = True,
                 hunt_groups: bool = False,
                 call_queues: bool = False,
                 xsi: bool = False,
                 ):
        &#34;&#34;&#34;Initialize an Org instance

        Args:
            name (str): The Organization name
            id (str): The Webex ID of the Organization
            parent (Webex, optional): The parent Webex instance that owns this Org.
            people (bool, optional): Whether to get all People for the Org. Default True.
            locations (bool, optional): Whether to get all Locations for the Org. Default True.
            hunt_groups (bool, optional): Whether to get all Hunt Groups for the Org. Default False.
            call_queues (bool, optional): Whether to get all Call Queues for the Org. Default False.
            xsi (bool, optional): Whether to get the XSI Endpoints for the Org. Default False.

        Returns:
            Org: This instance of the Org class

        &#34;&#34;&#34;

        # Instance attrs
        self._parent = parent
        self.call_queues: list[CallQueue] = None
        &#34;&#34;&#34;The Call Queues for this Org&#34;&#34;&#34;
        self.hunt_groups: list[HuntGroup] = None
        &#34;&#34;&#34;The Hunt Groups for this Org&#34;&#34;&#34;
        self.pickup_groups: list[PickupGroup] = None
        &#39;A list of the PickupGroup instances for this Org&#39;
        self.locations: list[Location] = []
        &#39;A list of the Location instances for this Org&#39;
        self.name: str = name
        &#39;The name of the Organization&#39;
        self.id: str = id
        &#39;&#39;&#39;The Webex ID of the Organization&#39;&#39;&#39;
        self.xsi: dict = {}
        &#34;&#34;&#34;The XSI details for the Organization&#34;&#34;&#34;
        self._params: dict = {&#34;orgId&#34;: self.id}
        self.licenses: list[dict] = []
        &#39;&#39;&#39;A list of all of the licenses for the Organization as a dictionary of names and IDs&#39;&#39;&#39;
        self.people: list[Person] = []
        &#39;&#39;&#39;A list of all of the Person stances for the Organization&#39;&#39;&#39;
        self.workspaces: list[Workspace] = None
        &#34;&#34;&#34;A list of the Workspace instances for this Org.&#34;&#34;&#34;
        self.workspace_locations: list[WorkspaceLocation] = None
        &#34;&#34;&#34;A list of the Workspace Location instanced for this Org.&#34;&#34;&#34;

        # Set the Authorization header based on how the instance was built
        self._headers = parent.headers
        self.licenses = self.__get_licenses()

        # Create a CPAPI instance for CPAPI work
        self._cpapi = CPAPI(self, self._parent._access_token)

        # Get all of the people if we aren&#39;t told not to
        if people:
            self.get_people()
        if locations:
            self.get_locations()
        if xsi:
            self.get_xsi_endpoints()
        if call_queues:
            self.get_call_queues()
        if hunt_groups:
            self.get_hunt_groups()

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    def __get_licenses(self):
        &#34;&#34;&#34;Gets all of the licenses for the Organization

        Returns:
            list: List of dictionaries containing the license name and ID

        &#34;&#34;&#34;
        logging.info(&#34;__get_licenses() started for org&#34;)
        license_list = []
        r = requests.get(_url_base + &#34;v1/licenses&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for item in response[&#39;items&#39;]:
            if &#34;Webex Calling&#34; in item[&#39;name&#39;]:
                wxc_license = True
                if &#34;Professional&#34; in item[&#39;name&#39;]:
                    wxc_type = &#34;person&#34;
                elif &#34;Workspace&#34; in item[&#39;name&#39;]:
                    wxc_type = &#34;workspace&#34;
                else:
                    wxc_type = &#34;unknown&#34;
            else:
                wxc_license = False
                wxc_type = None
            lic = {&#34;name&#34;: item[&#39;name&#39;],
                   &#34;id&#34;: item[&#39;id&#39;],
                   &#34;total&#34;: item[&#39;totalUnits&#39;],
                   &#34;consumed&#34;: item[&#39;consumedUnits&#39;],
                   &#34;subscription&#34;: item.get(&#34;subscriptionId&#34;, &#34;&#34;),
                   &#34;wxc_license&#34;: wxc_license,
                   &#34;wxc_type&#34;: wxc_type
                   }
            license_list.append(lic)
        return license_list

    @property
    def numbers(self):
        &#34;&#34;&#34;All of the Numbers for the Org

        Returns:
            list[dict]: List of dict containing information about each number

        &#34;&#34;&#34;
        my_numbers = self._cpapi.get_numbers()
        for num in my_numbers:
            if &#34;owner&#34; in num:
                person = self.get_person_by_id(num[&#39;owner&#39;][&#39;id&#39;])
                if person is not None:
                    num[&#39;owner&#39;] = person
            if &#34;location&#34; in num:
                location = self.get_location_by_name(num[&#39;location&#39;][&#39;name&#39;])
                if location is not None:
                    num[&#39;location&#39;] = location
        return my_numbers

    def get_location_by_name(self, name: str):
        &#34;&#34;&#34;Get the Location instance associated with a given Location ID

        Args:
            name (str): The full name of the Location to look for. (Case sensitive)

        Returns:
            Location: The Location instance. If no match is found, None is returned

        &#34;&#34;&#34;
        for location in self.locations:
            if location.name == name:
                return location
        return None

    def get_person_by_id(self, id: str):
        &#34;&#34;&#34;Get the Person instance associated with a given ID

        Args:
            id (str): The Webex ID of the Person to look for.

        Returns:
            Person: The Person instance. If no match is found, None is returned

        &#34;&#34;&#34;
        for person in self.people:
            if person.id == id:
                return person
        return None


    def __get_wxc_licenses(self):
        &#34;&#34;&#34;Get only the Webex Calling licenses from the Org.licenses attribute

        Returns:
            list[str]:

        &#34;&#34;&#34;
        logging.info(&#34;__get_wxc_licenses started&#34;)
        license_list = []
        for license in self.licenses:
            if license[&#39;wxc_license&#39;]:
                license_list.append(license[&#39;id&#39;])
        return license_list

    def get_wxc_person_license(self):
        &#34;&#34;&#34;Get the Webex Calling - Professional license ID

        Returns:
            str: The License ID

        &#34;&#34;&#34;
        logging.info(&#34;__get_wxc_person_license started to find available license&#34;)
        for license in self.licenses:
            if license[&#39;wxc_type&#39;] == &#34;person&#34;:
                return license[&#39;id&#39;]
        raise LicenseError(&#34;No Webex Calling Professional license found&#34;)

    def create_person(self, email: str,
                      location: str,
                      licenses: list = None,
                      calling: bool = True,
                      messaging: bool = True,
                      meetings: bool = True,
                      phone_number: str = None,
                      extension: str = None,
                      first_name: str = None,
                      last_name: str = None,
                      display_name: str = None,
                      ):
        &#34;&#34;&#34;Create a new user in Webex.

        Also creates a new Person instance for the created user.

        Args:
            email (str): The email address of the user
            location (str): The ID of the Location that the user is assigned to.
            licenses (list, optional): List of license IDs to assign to the user. Use this when the license IDs
            are known. To have the license IDs determined dynamically, use the `calling`, `messaging` and
            meetings` parameters.

            calling (bool, optional): BETA - Whether to assign Calling licenses to the user. Defaults to True.
            messaging (bool, optional): BETA - Whether to assign Messaging licenses to the user. Defaults to True.
            meetings (bool, optional): BETA - Whether to assign Messaging licenses to the user. Defaults to True.
            phone_number (str, optional): The phone number to assign to the user.
            extension (str, optional): The extension to assign to the user
            first_name (str, optional): The user&#39;s first name. Defaults to empty string.
            last_name (str, optional): The users&#39; last name. Defaults to empty string.
            display_name (str, optional): The full name of the user as displayed in Webex. If first name and last name are passed
                without display_name, the display name will be the concatenation of first and last name.

        Returns:
            Person: The Person instance of the newly-created user.

        &#34;&#34;&#34;
        if (first_name or last_name) and not display_name:
            display_name = f&#34;{first_name} {last_name}&#34;

        # Find the license IDs for each requested service, unless licenses was passed
        if not licenses:
            if calling:
                licenses.append(self.get_wxc_person_license())
            if messaging:
                pass
            if meetings:
                pass

        # Build the payload to send to the API
        payload = {&#34;emails&#34;: [email],
                   &#34;phoneNumbers&#34;: [{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: phone_number}],
                   &#34;extension&#34;: extension,
                   &#34;locationId&#34;: location,
                   &#34;displayName&#34;: display_name,
                   &#34;firstName&#34;: first_name,
                   &#34;lastName&#34;: last_name,
                   &#34;orgId&#34;: self.id,
                   &#34;licenses&#34;: licenses
                   }
        r = requests.post(_url_base + &#34;v1/people&#34;, headers=self._headers, params={&#34;callingData&#34;: &#34;true&#34;},
                          json=payload)
        response = r.json()
        if r.status_code == 200:
            person = Person(response[&#39;id&#39;], self, response)
            self.people.append(person)
            return person
        else:
            return f&#34;{r.status_code} - {r.text}&#34;

    def get_person_by_email(self, email):
        &#34;&#34;&#34;Get the Person instance from an email address

        Args:
            email (str): The email of the Person to return

        Returns:
            Person: Person instance object. None in returned when no Person is found

        &#34;&#34;&#34;
        logging.info(&#34;get_person_by_email() started&#34;)
        for person in self.people:
            if person.email == email:
                return person
        return None

    def get_xsi_endpoints(self):
        &#34;&#34;&#34;Get the XSI endpoints for the Organization.

        Also stores them in the Org.xsi attribute.

        Returns:
            dict: Org.xsi attribute dictionary with each endpoint as an entry.

        &#34;&#34;&#34;
        params = {&#34;callingData&#34;: &#34;true&#34;, **self._params}
        r = requests.get(_url_base + &#34;v1/organizations/&#34; + self.id, headers=self._headers, params=params)
        response = r.json()
        if &#34;xsiActionsEndpoint&#34; in response:
            self.xsi[&#39;actions_endpoint&#39;] = response[&#39;xsiActionsEndpoint&#39;]
            self.xsi[&#39;events_endpoint&#39;] = response[&#39;xsiEventsEndpoint&#39;]
            self.xsi[&#39;events_channel_endpoint&#39;] = response[&#39;xsiEventsChannelEndpoint&#39;]
        else:
            raise XSIError(&#34;XSI requested but not present in Org. Contact Cisco TAC to enable XSI.&#34;)
        return self.xsi

    def get_locations(self):
        &#34;&#34;&#34;Get the Locations for the Organization.

        Also stores them in the Org.locations attribute.

        Returns:
            list[Location]: List of Location instance objects. See the Locations class for attributes.

        &#34;&#34;&#34;
        logging.info(&#34;get_locations() started&#34;)
        r = requests.get(_url_base + &#34;v1/locations&#34;, headers=self._headers, params=self._params)
        response = r.json()
        # I am aware that this doesn&#39;t support pagination, so there will be a limit on number of Locations returned
        for location in response[&#39;items&#39;]:
            this_location = Location(self, location[&#39;id&#39;], location[&#39;name&#39;], address=location[&#39;address&#39;])
            self.locations.append(this_location)

        return self.locations

    def get_workspaces(self):
        &#34;&#34;&#34;Get the Workspaces and Workspace Locations for the Organizations.

        Also stores them in the Org.workspaces and Org.workspace_locations attributes.

        Returns:
            list[Workspace]: List of Workspace instance objects. See the Workspace class for attributes.

        &#34;&#34;&#34;
        logging.info(&#34;Getting Workspaces&#34;)
        self.workspaces = []
        r = requests.get(_url_base + &#34;v1/workspaces&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for workspace in response[&#39;items&#39;]:
            this_workspace = Workspace(self, workspace[&#39;id&#39;], workspace)
            self.workspaces.append(this_workspace)

        logging.info(&#34;Getting Workspace Locations&#34;)
        self.workspace_locations = []
        r = requests.get(_url_base + &#34;v1/workspaceLocations&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for location in response[&#39;items&#39;]:
            this_location = WorkspaceLocation(self, location[&#39;id&#39;], location)
            self.workspace_locations.append(this_location)

        return self.workspaces

    def get_pickup_groups(self):
        &#34;&#34;&#34;Get all of the Call Pickup Groups for an Organization.

        Also stores them in the Org.pickup_groups attribute.

        Returns:
            list[PickupGroup]: List of Call Pickup Groups as a list of dictionaries.
            See the PickupGroup class for attributes.

        &#34;&#34;&#34;
        logging.info(&#34;get_pickup_groups() started&#34;)
        self.pickup_groups = []
        # First we need to know if we already have locations, because they are needed
        # for the pickup groups call
        if not self.locations:
            self.get_locations()
        # Loop through all of the locations and get their pickup groups
        # We will create a new instance of the PickupGroup class when we find one
        for location in self.locations:
            r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + location.id + &#34;/callPickups&#34;,
                             headers=self._headers)
            response = r.json()
            for item in response[&#39;callPickups&#39;]:
                pg = PickupGroup(self, location.id, item[&#39;id&#39;], item[&#39;name&#39;])
                self.pickup_groups.append(pg)
        return self.pickup_groups

    def get_call_queues(self):
        &#34;&#34;&#34;Get the Call Queues for an Organization.

        Also stores them in the Org.call_queues attribute.

        Returns:
            list[CallQueue]: List of CallQueue instances for the Organization

        &#34;&#34;&#34;
        logging.info(&#34;get_call_queues() started&#34;)
        self.call_queues = []
        if not self.locations:
            self.get_locations()
        r = requests.get(_url_base + &#34;v1/telephony/config/queues&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for queue in response[&#39;queues&#39;]:
            id = queue.get(&#34;id&#34;)
            name = queue.get(&#34;name&#34;, None)
            location_id = queue.get(&#34;locationId&#34;)
            phone_number = queue.get(&#34;phoneNumber&#34;, None)
            extension = queue.get(&#34;extension&#34;, None)
            enabled = queue.get(&#34;enabled&#34;)

            queue = CallQueue(self, id, name, location_id, phone_number, extension, enabled, get_config=True)
            self.call_queues.append(queue)
        return self.call_queues

    def get_hunt_groups(self):
        &#34;&#34;&#34;Get the Hunt Groups for an Organization.

        Also stores them in the Org.hunt_groups attribute.

        Returns:
            list[HuntGroup]: List of HuntGroup instances for the Organization

        &#34;&#34;&#34;
        logging.info(&#34;get_hunt_groups() started&#34;)
        self.hunt_groups = []
        if not self.locations:
            self.get_locations()
        r = requests.get(_url_base + &#34;v1/telephony/config/huntGroups&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for hg in response[&#39;huntGroups&#39;]:
            hunt_group = HuntGroup(self, hg[&#39;id&#39;], hg[&#39;name&#39;], hg[&#39;locationId&#39;], hg[&#39;enabled&#39;],
                                   hg.get(&#34;phoneNumber&#34;, &#34;&#34;), hg.get(&#34;extension&#34;, &#34;&#34;))
            self.hunt_groups.append(hunt_group)
        return self.hunt_groups

    def get_people(self):
        &#34;&#34;&#34;Get all of the people within the Organization.

        Also creates a Person instance and stores it in the Org.people attributes

        Returns:
            list[Person]: List of Person instances

        &#34;&#34;&#34;
        logging.info(&#34;get_people() started&#34;)
        params = {&#34;max&#34;: &#34;1000&#34;, &#34;callingData&#34;: &#34;true&#34;, **self._params}
        r = requests.get(_url_base + &#34;v1/people&#34;, headers=self._headers, params=params)
        people_list = r.json()

        if &#34;next&#34; in r.links:
            keep_going = True
            next_url = r.links[&#39;next&#39;][&#39;url&#39;]
            while keep_going:
                r = requests.get(next_url, headers=self._headers)
                new_people = r.json()
                if &#34;items&#34; not in new_people:
                    continue
                people_list[&#39;items&#39;].extend(new_people[&#39;items&#39;])
                if &#34;next&#34; not in r.links:
                    keep_going = False
                else:
                    next_url = r.links[&#39;next&#39;][&#39;url&#39;]

        self.wxc_licenses = self.__get_wxc_licenses()
        for person in people_list[&#39;items&#39;]:
            this_person = Person(person[&#39;id&#39;], parent=self, config=person)
            self.people.append(this_person)
        return self.people

    def get_wxc_people(self):
        &#34;&#34;&#34;Get all of the people within the Organization **who have Webex Calling**

        Returns:
            list[Person]: List of Person instances of people who have a Webex Calling license

        &#34;&#34;&#34;
        if not self.people:
            self.get_people()
        wxc_people = []
        for person in self.people:
            if person.wxc:
                wxc_people.append(person)
        return wxc_people

    def get_license_name(self, license_id: str):
        &#34;&#34;&#34;Gets the name of a license by its ID

        Args:
            license_id (str): The License ID

        Returns:
            str: The License name. None if not found.

        &#34;&#34;&#34;
        for license in self.licenses:
            if license[&#39;id&#39;] == license_id:
                return license[&#39;name&#39;]
        return None


class Location:
    def __init__(self, parent: Org, location_id: str, name: str, address: dict = None):
        &#34;&#34;&#34;Initialize a Location instance

        Args:
            location_id (str): The Webex ID of the Location
            name (str): The name of the Location
            address (dict): The address information for the Location

        Returns:
             Location (object): The Location instance

        &#34;&#34;&#34;
        self._parent = parent
        self.id: str = location_id
        &#34;&#34;&#34;The Webex ID of the Location&#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;The name of the Location&#34;&#34;&#34;
        self.address: dict = address
        &#34;&#34;&#34;The address of the Location&#34;&#34;&#34;

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    @property
    def spark_id(self):
        &#34;&#34;&#34;The ID used by all of the underlying services.&#34;&#34;&#34;
        bytes = base64.b64decode(self.id + &#34;===&#34;)
        spark_id = bytes.decode(&#34;utf-8&#34;)
        return spark_id

    @property
    def hunt_groups(self):
        &#34;&#34;&#34;List of HuntGroup instances for this Location&#34;&#34;&#34;
        my_hunt_groups = []
        for hg in self._parent.hunt_groups:
            if hg.location == self.id:
                my_hunt_groups.append(hg)
        return my_hunt_groups

    @property
    def call_queues(self):
        &#34;&#34;&#34;List of CallQueue instances for this Location&#34;&#34;&#34;
        my_call_queues = []
        for cq in self._parent.call_queues:
            if cq.location_id == self.id:
                my_call_queues.append(cq)
        return my_call_queues

    @property
    def available_numbers(self):
        &#34;&#34;&#34;Returns all of the available numbers for the Location.

        Only returns active numbers, so numbers that have not been activated yet will not be returned.

        Returns:
            list[dict]: A list of available numbers, in dict form

        &#34;&#34;&#34;
        available_numbers = []
        for number in self._parent.numbers:
            if number[&#39;location&#39;].name == self.name and number.get(&#39;state&#39;, &#34;&#34;) == &#34;ACTIVE&#34;:
                available_numbers.append(number)
        return available_numbers


class Person:
    def __init__(self, user_id, parent: Org = None, config: dict = None):
        &#34;&#34;&#34;
        Initialize a new Person instance. If only the `user_id` is provided, the API calls will be made to get
            the config from Webex. To save on API calls, the config can be provided which will set the attributes
            without an API call.
        Args:
            user_id (str): The Webex ID of the person
            parent (object, optional): The parent object that created the Person instance. Used when the Person
                is created within the Org instance
            config (dict, optional): A dictionary of raw values from the `GET v1/people` items. Not normally used
                except for automated people population from the Org init.
        &#34;&#34;&#34;
        self.id = user_id
        &#34;&#34;&#34;The Webex ID of the Person&#34;&#34;&#34;
        self._parent = parent
        &#34;&#34;&#34;The parent instance that created this Person&#34;&#34;&#34;

        # Attributes
        self.email: str = &#34;&#34;
        &#34;&#34;&#34;The user&#39;s email address&#34;&#34;&#34;
        self.first_name: str = &#34;&#34;
        &#34;&#34;&#34;The user&#39;s first name&#34;&#34;&#34;
        self.last_name: str = &#34;&#34;
        &#34;&#34;&#34;The user&#39;s last name&#34;&#34;&#34;
        self.display_name: str = &#34;&#34;
        &#34;&#34;&#34;The user&#39;s name as displayed in Webex&#34;&#34;&#34;
        self.wxc: bool = False
        &#39;&#39;&#39;True if this is a Webex Calling User&#39;&#39;&#39;
        self.licenses: list = []
        &#34;&#34;&#34;List of licenses assigned to the person&#34;&#34;&#34;
        self.location: str = &#34;&#34;
        &#34;&#34;&#34;The Webex ID of the user&#39;s assigned location&#34;&#34;&#34;
        self.roles: list = []
        &#34;&#34;&#34;The roles assigned to this Person in Webex&#34;&#34;&#34;
        self.vm_config: dict = {}
        &#39;&#39;&#39;Dictionary of the VM config as returned by Webex API&#39;&#39;&#39;
        self.recording: dict = {}
        &#34;&#34;&#34;Dictionary of the Recording config as returned by Webex API&#34;&#34;&#34;
        self.barge_in: dict = {}
        &#34;&#34;&#34;Dictionary of Barge-In config as returned by Webex API&#34;&#34;&#34;
        self.call_forwarding: dict = {}
        &#39;&#39;&#39;Dictionary of the Call Forwarding config as returned by Webex API&#39;&#39;&#39;
        self.caller_id: dict = {}
        &#34;&#34;&#34;Dictionary of Caller ID config as returned by Webex API&#34;&#34;&#34;
        self.intercept: dict = {}
        &#34;&#34;&#34;Dictionary of Call Intercept config as returned by Webex API&#34;&#34;&#34;
        self.dnd: dict = {}
        &#34;&#34;&#34;Dictionary of DND settings as returned by Webex API&#34;&#34;&#34;
        self.calling_behavior: dict = {}
        &#34;&#34;&#34;Dictionary of Calling Behavior as returned by Webex API&#34;&#34;&#34;
        self.xsi = None
        &#34;&#34;&#34;Holds the XSI instance when created with the `start_xsi()` method.&#34;&#34;&#34;
        self.numbers: list = []
        &#34;&#34;&#34;The phone numbers for this person from Webex CI&#34;&#34;&#34;
        self.extension: str = None
        &#34;&#34;&#34;The extension for this person&#34;&#34;&#34;
        self._hunt_groups: list = []
        &#34;&#34;&#34;A list of the Hunt Group instances that this user is an Agent for&#34;&#34;&#34;
        self._call_queues: list = []
        &#34;&#34;&#34;A list of the Call Queue instances that this user is an Agent for&#34;&#34;&#34;

        # API-related attributes
        self._headers = parent._headers
        self._params = {&#34;orgId&#34;: parent.id, &#34;callingData&#34;: &#34;true&#34;}

        # If the config was passed, process it. If not, make the API call for the Person ID and then process
        if config:
            self.__process_api_data(config)
        else:
            response = self.__get_webex_data(f&#34;v1/people/{self.id}&#34;)
            self.__process_api_data(response)

    def __process_api_data(self, data: dict):
        &#34;&#34;&#34;
        Takes the API data passed as the `data` argument and parses it to the instance attributes.
        Args:
            data (dict): A dictionary of the raw data returned by the `v1/people` API call
        &#34;&#34;&#34;
        self.email = data[&#39;emails&#39;][0]
        self.extension = data.get(&#34;extension&#34;, &#34;&#34;)
        self.location = data.get(&#34;location&#34;, &#34;&#34;)
        self.display_name = data.get(&#34;displayName&#34;, &#34;&#34;)
        self.first_name = data.get(&#34;firstName&#34;, &#34;&#34;)
        self.last_name = data.get(&#34;lastName&#34;, &#34;&#34;)
        self.roles = data.get(&#34;roles&#34;, [])
        self.numbers = data.get(&#34;phoneNumbers&#34;, [])
        self.licenses = data.get(&#34;licenses&#34;, [])
        for license in self.licenses:
            if license in self._parent.wxc_licenses:
                self.wxc = True

    def __str__(self):
        return f&#34;{self.email},{self.display_name}&#34;

    def __repr__(self):
        return self.id

    # The following is to simplify the API call. Eventually I may open this as a public method to
    # allow arbitrary API calls
    def __get_webex_data(self, endpoint: str, params: dict = None):
        &#34;&#34;&#34;
        Issue a GET to the Webex API
        Args:
            endpoint (str): The endpoint of the call (i.e. &#34;v1/people&#34; or &#34;/v1/people/{Person.id}&#34;)
            params (dict): Any additional params to be passed in the query (i.e. {&#34;callingData&#34;:&#34;true&#34;}
        Returns:
            dict: The response from the Webex API
        &#34;&#34;&#34;
        if params is None:
            params = {}
        logging.info(f&#34;__get_webex_data started for using {endpoint}&#34;)
        my_params = {**params, **self._params}
        r = requests.get(_url_base + endpoint, headers=self._headers, params=my_params)
        if r.status_code in [200]:
            response = r.json()
            return response
        else:
            return False

    def __put_webex_data(self, endpoint: str, payload: dict, params: dict = None):
        &#34;&#34;&#34;
        Issue a PUT to the Webex API
        Args:
            endpoint: The endpoint of the call (i.e. &#34;v1/people&#34; or &#34;/v1/people/{Person.id}&#34;)
            payload: A dict to send as the JSON payload of the PUT
            params: Any additional params to be passed in the query (i.e. {&#34;callingData&#34;:&#34;true&#34;}
        Returns:
            bool: True if successful, False if not
        &#34;&#34;&#34;
        if params is None:
            params = {}
        logging.info(f&#34;__put_webex_data started using {endpoint}&#34;)
        my_params = {**params, **self._params}
        r = requests.put(_url_base + endpoint, headers=self._headers, params=my_params, json=payload)
        response_code = r.status_code
        if response_code == 200 or response_code == 204:
            logging.info(&#34;Push successful&#34;)
            return True
        else:
            logging.info(&#34;Push failed&#34;)
            raise PutError(r.text)

    @property
    def spark_id(self):
        user_id_bytes = base64.b64decode(self.id + &#34;===&#34;)
        spark_id = user_id_bytes.decode(&#34;utf-8&#34;)
        return spark_id

    def assign_wxc(self, location: Location, phone_number: str = None, extension: str = None):
        &#34;&#34;&#34;
        Assign Webex Calling to the user, along with a phone number and/or an extension.

        Args:
            location (Location): The Location instance to assign the Person to.
            phone_number (str, optional): The phone number to assign to the Person.
            extension (str, optional): The extension to assign to the Person

        Returns:
            bool: True on success, False if otherwise
        &#34;&#34;&#34;
        # To assign Webex Calling to a Person, we need to find the License ID for Webex Calling Professional
        license = self._parent.get_wxc_person_license()
        self.licenses.append(license)

        # Call the update_person() method to update the new values.
        success = self.update_person(numbers=[{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: phone_number}],
                                     extension=extension, location=location.id)
        if success:
            return True
        else:
            return False

    def start_xsi(self):
        &#34;&#34;&#34;Starts an XSI session for the Person&#34;&#34;&#34;
        self.xsi = XSI(self)
        return self.xsi

    def reset_vm_pin(self, pin: str = None):
        &#34;&#34;&#34;Resets the user&#39;s voicemail PIN. If no PIN is provided, the reset command is sent, and assumes that
            a default PIN exists for the organization. Because of the operation of Webex, if a PIN is provided, the
            method will temporarily set the Org-wide PIN to the chosen PIN, then does the reset, then un-sets the
            Org default in Control Hub. ***This can cause unintended consequences if a PIN is provided and the Org
            already has a default PIN** because that PIN will be un-set at the end of this method.

            Args:
                pin (str): The new temporary PIN to set for the Person
        &#34;&#34;&#34;
        self._parent._cpapi.reset_vm_pin(self, pin=pin)

    def get_full_config(self):
        &#34;&#34;&#34;Fetches all of the Webex Calling settings for the Person. Due to the number of API calls, this
            method is not performed automatically on Person init and should be called for each Person during
            any subsequent processing. If you are only interested in one of the features, calling that method
            directly can significantly improve the time to return data.
        &#34;&#34;&#34;
        logging.info(f&#34;Getting the full config for {self.email}&#34;)
        if self.wxc:
            self.get_call_forwarding()
            self.get_vm_config()
            self.get_intercept()
            self.get_call_recording()
            self.get_caller_id()
            self.get_dnd()
            self.get_calling_behavior()
            self.get_barge_in()
            return self
        else:
            logging.info(f&#34;{self.email} is not a Webex Calling user.&#34;)

    @property
    def hunt_groups(self):
        &#34;&#34;&#34;
        The Hunt Groups that this user is an Agent for.
        Returns:
            list[HuntGroup]: A list of the `HuntGroup` instances the user belongs to
        &#34;&#34;&#34;
        # First, we need to make sure we know about the Org&#39;s Hunt Groups. If not, pull them.
        if self._parent.hunt_groups is None:
            self._parent.get_hunt_groups()
        hunt_groups = []
        for hg in self._parent.hunt_groups:
            # Step through the agents for the Hunt Group to see if this person is there
            for agent in hg.agents:
                if agent[&#39;id&#39;] == self.id:
                    hunt_groups.append(hg)
        self._hunt_groups = hunt_groups
        return self._hunt_groups

    @property
    def call_queues(self):
        &#34;&#34;&#34;
        The Call Queues that this user is an Agent for.
        Returns:
            list[CallQueue]: A list of the `CallQueue` instances the user belongs to
        &#34;&#34;&#34;
        # First, we need to make sure we know about the Org&#39;s Hunt Groups. If not, pull them.
        if self._parent.call_queues is None:
            self._parent.get_call_queues()
        call_queues = []
        for cq in self._parent.call_queues:
            # Step through the agents for the Hunt Group to see if this person is there
            for agent in cq.config[&#39;agents&#39;]:
                if agent[&#39;id&#39;] == self.id:
                    call_queues.append(cq)
        self._call_queues = call_queues
        return self._call_queues

    def get_call_forwarding(self):
        &#34;&#34;&#34;Fetch the Call Forwarding config for the Person from the Webex API&#34;&#34;&#34;
        logging.info(&#34;get_call_forwarding() started&#34;)
        self.call_forwarding = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callForwarding&#34;)
        return self.call_forwarding

    def get_barge_in(self):
        &#34;&#34;&#34;Fetch the Barge-In config for the Person from the Webex API&#34;&#34;&#34;
        logging.info(&#34;get_barge_in() started&#34;)
        self.barge_in = self.__get_webex_data(f&#34;v1/people/{self.id}/features/bargeIn&#34;)
        return self.barge_in

    def get_vm_config(self):
        &#34;&#34;&#34;Fetch the Voicemail config for the Person from the Webex API&#34;&#34;&#34;
        logging.info(&#34;get_vm_config() started&#34;)
        self.vm_config = self.__get_webex_data(f&#34;v1/people/{self.id}/features/voicemail&#34;)
        return self.vm_config

    def push_vm_config(self):
        &#34;&#34;&#34;Pushes the current Person.vm_config attributes back to Webex&#34;&#34;&#34;
        logging.info(f&#34;Pushing VM Config for {self.email}&#34;)
        success = self.__put_webex_data(f&#34;v1/people/{self.id}/features/voicemail&#34;, self.vm_config)
        if success:
            self.get_vm_config()
            return self.vm_config

    def enable_vm_to_email(self, email: str = None, push=True):
        &#34;&#34;&#34;
        Change the Voicemail config to enable sending a copy of VMs to specified email address. If the email param
            is not present, it will use the Person&#39;s email address as the default.
        Args:
            email (optional): The email address to send VMs to.
            push (optional): Whether to immediately push the change to Webex. Defaults to True.
        Returns:
            dict: The `Person.vm_config` attribute
        &#34;&#34;&#34;
        if email is None:
            email = self.email
        self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;enabled&#39;] = True
        self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;emailId&#39;] = email
        if push:
            return self.push_vm_config()
        else:
            return self.vm_config

    def disable_vm_to_email(self, push=True):
        self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;enabled&#39;] = False
        if push:
            return self.push_vm_config()
        else:
            return self.vm_config

    def get_intercept(self):
        logging.info(&#34;get_intercept() started&#34;)
        self.intercept = self.__get_webex_data(f&#34;v1/people/{self.id}/features/intercept&#34;)
        return self.intercept

    def get_call_recording(self):
        logging.info(&#34;get_call_recording() started&#34;)
        self.recording = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callRecording&#34;)
        return self.recording

    def get_caller_id(self):
        logging.info(&#34;get_caller_id() started&#34;)
        self.caller_id = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callerId&#34;)
        return self.caller_id

    def get_dnd(self):
        logging.info(f&#34;Getting DND for {self.email}&#34;)
        self.dnd = self.__get_webex_data(f&#34;v1/people/{self.id}/features/doNotDisturb&#34;)
        return self.dnd

    def get_calling_behavior(self):
        logging.info(f&#34;Getting Calling Behavior for {self.email}&#34;)
        self.calling_behavior = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callingBehavior&#34;)
        return self.calling_behavior

    def license_details(self):
        &#34;&#34;&#34;
        Get the full details for all of the licenses assigned to the Person
        Returns:
            list[dict]: List of the license dictionaries
        &#34;&#34;&#34;
        license_list = []
        for license in self.licenses:
            for org_lic in self._parent.licenses:
                if license == org_lic[&#39;id&#39;]:
                    license_list.append(org_lic)
        return license_list

    def refresh_person(self, raw: bool = False):
        &#34;&#34;&#34;
        Pull a fresh copy of the Person details from the Webex API and update the instance. Useful when changes
            are made outside of the script or changes have been pushed and need to get updated info.
        Args:
            raw (bool, optional): Return the &#34;raw&#34; config from the as a dict. Useful when making changes to
                the user, because you have to send all of the values over again.
        Returns:
            bool: True if successful, False if not
        &#34;&#34;&#34;
        response = self.__get_webex_data(f&#34;v1/people/{self.id}&#34;)
        if response:
            self.__process_api_data(response)
            if raw:
                return response
            else:
                return True
        else:
            return False

    def update_person(self,
                      email=None,
                      numbers=None,
                      extension=None,
                      location=None,
                      display_name=None,
                      first_name=None,
                      last_name=None,
                      roles=None,
                      licenses=None):
        &#34;&#34;&#34;
        Update the Person in Webex. Pass only the arguments that you want to change. Other attributes will be populated
            with the existing values from the instance. *Note:* This allows changes directly to the instance attrs to
            be pushed to Webex. For example, changing Person.extension and then calling `update_person()` with no
            arguments will still push the extension change. This allows for a lot of flexibility if a method does not
            exist to change the desired value. It is also the method other methods use to push their changes to Webex.
        Args:
            email (str): The email address of the Person
            numbers (list): The list of number dicts (&#34;type&#34; and &#34;value&#34; keys)
            extension (str): The user&#39;s extension
            location (str): The Location ID for the user. Note that this can&#39;t actually be changed yet.
            display_name (str): The Display Name for the Person
            first_name (str): The Person&#39;s first name
            last_name (str): The Person&#39;s last name
            roles (list): List of Role IDs
            licenses (list): List of License IDs
        Returns:
            bool: True if successful. False if not.
        &#34;&#34;&#34;
        # Build the payload using the arguments and the instance attrs
        payload = {}
        if email is None:
            email = self.email
        payload[&#39;emails&#39;] = [email]
        if numbers is None:
            numbers = self.numbers
        payload[&#39;phoneNumbers&#39;] = numbers
        if extension is None:
            if self.extension:
                extension = self.extension
        payload[&#39;extension&#39;] = extension
        if location is None:
            location = self.location
        payload[&#39;location&#39;] = location
        if display_name is None:
            display_name = self.display_name
        payload[&#39;displayName&#39;] = display_name
        if first_name is None:
            first_name = self.first_name
        payload[&#39;firstName&#39;] = first_name
        if last_name is None:
            last_name = self.last_name
        payload[&#39;lastName&#39;] = last_name
        if roles is None:
            roles = self.roles
        payload[&#39;roles&#39;] = roles
        if licenses is None:
            licenses = self.licenses
        payload[&#39;licenses&#39;] = licenses

        params = {&#34;callingData&#34;: &#34;true&#34;}
        success = self.__put_webex_data(f&#34;v1/people/{self.id}&#34;, payload, params)
        if success:
            self.refresh_person()
            return True
        else:
            return False

    def set_calling_only(self):
        &#34;&#34;&#34;
        Removes the Messaging and Meetings licenses, leaving only the Calling capability.

        Returns:
            Person: The instance of this person with the updated values

        &#34;&#34;&#34;
        logging.info(f&#34;Setting {self.email} to Calling-Only&#34;)
        # First, iterate the existing licenses and remove the ones we don&#39;t want
        # Build a list that contains the values to match on to remove
        remove_matches = [&#34;messaging&#34;,
                          &#34;meeting&#34;,
                          &#34;free&#34;]
        new_licenses = []
        for license in self.licenses:
            logging.debug(f&#34;Checking license: {license}&#34;)
            lic_name = self._parent.get_license_name(license)
            logging.debug(f&#34;License Name: {lic_name}&#34;)
            if any(match in lic_name.lower() for match in remove_matches):
                if &#34;screen share&#34; in lic_name.lower():
                    logging.debug(f&#34;{lic_name} matches but is needed&#34;)
                    new_licenses.append(license)
                else:
                    logging.debug(f&#34;License should be removed&#34;)
                    continue
            else:
                logging.debug(f&#34;Keeping license&#34;)
                new_licenses.append(license)

        success = self.update_person(licenses=new_licenses)
        return self

    def change_phone_number(self, new_number: str, new_extension: str = None):
        &#34;&#34;&#34;
        Change a person&#39;s phone number and extension
        Args:
            new_number (str): The new phone number for the person
            new_extension (str, optional): The new extension, if changing. Omit to leave the same value.
        Returns:
            Person: The instance of this person, with the new values
        &#34;&#34;&#34;
        if not new_extension:
            if self.extension:
                extension = self.extension
            else:
                extension = None
        else:
            extension = new_extension

        # Call the update_person() method
        success = self.update_person(numbers=[{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: new_number}], extension=extension)
        return self


class PickupGroup:
    def __init__(self, parent, location, id, name, users=None):
        self._parent: object = parent
        self.location_id: str = location
        &#34;&#34;&#34;The Webex ID of the Location associated with this Pickup Group&#34;&#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Pickup Group&#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;The name of the Pickup Group&#34;&#34;&#34;
        self.users: list = []
        &#34;&#34;&#34;All of the users (agents) assigned to this Pickup Group&#34;&#34;&#34;
        # If no agents were passed, we need to go get the configuration of the PickupGroup
        if users is None:
            r = requests.get(_url_base + f&#34;v1/telephony/config/locations/{self.location_id}/callPickups/{self.id}&#34;,
                             headers=self._parent._headers
                             )
            response = r.json()
            # TODO It doesn&#39;t make sense to create a new Person instance for the below.
            #      Once we have an API and a class for Workspaces, it would make sense to tie
            #      the agents to the Person or Workspace instance
            # For now, we just write the values that we get back and the user can find the people with the
            # Person-specific methods
            for agent in response[&#39;agents&#39;]:
                self.users.append(agent)

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    def get_config(self):
        &#34;&#34;&#34;Gets the configuration of the Pickup Group from Webex
        Returns:
            dict: The configuration of the Pickup Group
        &#34;&#34;&#34;
        config = {**self}
        return config


class CallQueue:
    def __init__(self, parent, id, name, location, phone_number, extension, enabled, get_config=True):
        self._parent: Org = parent
        &#34;&#34;&#34;The parent org of this Call Queue&#34;&#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Call Queue&#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;The name of the Call Queue&#34;&#34;&#34;
        self.location_id: str = location
        &#34;&#34;&#34;The Webex ID of the Location associated with this Call Queue&#34;&#34;&#34;
        self.phone_number: str = phone_number
        &#34;&#34;&#34;The DID of the Call Queue&#34;&#34;&#34;
        self.extension: str = extension
        &#34;&#34;&#34;The extension of the Call Queue&#34;&#34;&#34;
        self.enabled: bool = enabled
        &#34;&#34;&#34;True if the Call Queue is enabled. False if disabled&#34;&#34;&#34;
        self.call_forwarding: dict = {}
        &#34;&#34;&#34;The Call Forwarding config for the Call Queue&#34;&#34;&#34;
        self.config: dict = {}
        &#34;&#34;&#34;The configuration dictionary for the Call Queue&#34;&#34;&#34;

        if get_config:
            self.get_queue_config()
            self.get_queue_forwarding()

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    def get_queue_config(self):
        &#34;&#34;&#34;
        Get the configuration of this Call Queue instance
        Returns:
            CallQueue.config: The config dictionary of this Call Queue
        &#34;&#34;&#34;
        r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id + &#34;/queues/&#34; + self.id,
                         headers=self._parent._headers)
        response = r.json()
        self.config = response
        return self.config

    def get_queue_forwarding(self):
        &#34;&#34;&#34;
        Get the Call Forwarding settings for this Call Queue instance

        Returns:
            CallQueue.call_forwarding: The Call Forwarding settings for the Person
        &#34;&#34;&#34;
        # TODO: The rules within Call Forwarding are weird. The rules come back in this call, but they are
        #       different than the /selectiveRules response. It makes sense to aggregate them, but that probably
        #       requires the object-&gt;JSON mapping that we need to do for all classes
        r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id +
                         &#34;/queues/&#34; + self.id + &#34;/callForwarding&#34;,
                         headers=self._parent._headers)
        response = r.json()
        self.call_forwarding = response
        return self.call_forwarding

    def push(self):
        &#34;&#34;&#34;
        Push the contents of the CallQueue.config back to Webex
        Returns:
            CallQueue.config: The updated config attribute pulled from Webex after pushing the change
        &#34;&#34;&#34;
        # TODO: Right now this only pushes .config. It should also push .call_forwarding and .forwarding_rules
        logging.info(f&#34;Pushing Call Queue config to Webex for {self.name}&#34;)
        url = _url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id + &#34;/queues/&#34; + self.id
        print(url)
        r = requests.put(url,
                         headers=self._parent._headers, json=self.config)
        response = r.status_code
        self.get_queue_config()
        return self.config


class XSI:
    def __init__(self, parent, get_profile: bool = False, cache: bool = False):
        &#34;&#34;&#34;
        The XSI class holds all of the relevant XSI data for a Person
        Args:
            parent (Person): The Person who this XSI instance belongs to
            get_profile (bool): Whether or not to automatically get the XSI Profile
            cache (bool): Whether to cache the XSI data (True) or pull it &#34;live&#34; every time (**False**)
        &#34;&#34;&#34;
        logging.info(f&#34;Initializing XSI instance for {parent.email}&#34;)
        # First we need to get the XSI User ID for the Webex person we are working with
        logging.info(&#34;Getting XSI identifiers&#34;)
        user_id_bytes = base64.b64decode(parent.id + &#34;===&#34;)
        user_id_decoded = user_id_bytes.decode(&#34;utf-8&#34;)
        user_id_bwks = user_id_decoded.split(&#34;/&#34;)[-1]
        self.id = user_id_bwks

        # Inherited attributes
        self.xsi_endpoints = parent._parent.xsi
        self._cache = cache

        # API attributes
        self._headers = {&#34;Content-Type&#34;: &#34;application/json&#34;,
                         &#34;Accept&#34;: &#34;application/json&#34;,
                         &#34;X-BroadWorks-Protocol-Version&#34;: &#34;25.0&#34;,
                         **parent._headers}
        self._params = {&#34;format&#34;: &#34;json&#34;}

        # Attribute definitions
        self._calls: list = []
        self._profile: dict = {}
        &#34;&#34;&#34;The XSI Profile for this Person&#34;&#34;&#34;
        self._registrations: dict = {}
        &#34;&#34;&#34;The Registrations associated with this Person&#34;&#34;&#34;
        self.fac = None
        self.services = {}
        self._alternate_numbers: dict = {}
        &#34;&#34;&#34;The Alternate Numbers for the Person&#34;&#34;&#34;
        self._anonymous_call_rejection: dict = {}
        &#34;&#34;&#34;The Anonymous Call Rejection settings for this Person&#34;&#34;&#34;
        self._single_number_reach: dict = {}
        &#34;&#34;&#34;The SNR (Office Anywhere) settings for this Person&#34;&#34;&#34;
        self._monitoring: dict = {}
        &#34;&#34;&#34;The BLF/Monitoring settings for this Person&#34;&#34;&#34;
        self.conference: object = None

        # Get the profile if we have been asked to
        if get_profile:
            self.get_profile()

    def new_call(self, address: str = None):
        &#34;&#34;&#34;
        Create a new Call instance
        Args:
            address (str, optional): The address to originate a call to
        Returns:
            Call: The Call instance
        &#34;&#34;&#34;
        # If we got an address, pass it to the new instance
        if address is not None:
            call = Call(self, address=address)
        else:
            call = Call(self)
        self._calls.append(call)
        return call

    def new_conference(self, calls: list = [], comment: str = &#34;&#34;):
        &#34;&#34;&#34;
        Crates a new Conference instance. A user can only have one Conference instance, so this will replace any
        previous Conference. At the moment, this **should not be called directly** and will be done dynamically by
        a Call.conference()
        Args:
            calls (list): A list of Call IDs involved in this conference. A conference is always started with only
                two Call IDs. Call IDs after the first two will be ignored.
            comment (str, optional): An optional text comment for the conference
        Returns:
            The instance of the Conference class
        &#34;&#34;&#34;
        self.conference = Conference(self, calls, comment)
        return self.conference

    @property
    def calls(self):
        &#34;&#34;&#34;
        Get the list of active calls and creates Call instances. Also destroys any Call instances that are no longer
        valid.
        Returns:
            list[Call]: List of Call instances
        &#34;&#34;&#34;
        # First wipe out all of the existing instances
        for call in self._calls:
            del call
        self._calls.clear()
        calls_data: list = self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/calls&#34;)
        logging.debug(f&#34;Calls Data: {calls_data}&#34;)
        if &#34;call&#34; not in calls_data[&#39;Calls&#39;]:
            self._calls = []
            return self._calls
        if type(calls_data[&#39;Calls&#39;][&#39;call&#39;]) is dict:
            this_call = Call(self, id=calls_data[&#39;Calls&#39;][&#39;call&#39;][&#39;callId&#39;][&#39;$&#39;])
            self._calls.append(this_call)
        elif type(calls_data[&#39;Calls&#39;][&#39;call&#39;]) is list:
            for call in calls_data[&#39;Calls&#39;][&#39;call&#39;]:
                this_call = Call(self, id=call[&#39;callId&#39;][&#39;$&#39;])
                self._calls.append(this_call)
        return self._calls

    def __get_xsi_data(self, url, params: dict = {}):
        params = {**params, **self._params}
        r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + url, headers=self._headers, params=params)
        if r.status_code == 200:
            try:
                response = r.json()
            except json.decoder.JSONDecodeError:
                response = r.text
            return_data = response
        elif r.status_code == 404:
            return_data = False
        return return_data

    @property
    def monitoring(self):
        &#34;&#34;&#34;The Monitoring/BLF settings for this person&#34;&#34;&#34;
        if not self._monitoring or not self._cache:
            self._monitoring = self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/BusyLampField&#34;)
        return self._monitoring

    @property
    def single_number_reach(self):
        &#34;&#34;&#34;The SNR (Office Anywhere) settings for this Person&#34;&#34;&#34;
        if not self._single_number_reach or not self._cache:
            self._single_number_reach = \
                self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/BroadWorksAnywhere&#34;)
        return self._single_number_reach

    @property
    def anonymous_call_rejection(self):
        &#34;&#34;&#34;The Anonymous Call Rejection settings for this Person&#34;&#34;&#34;
        if not self._anonymous_call_rejection or not self._cache:
            self._anonymous_call_rejection = \
                self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/AnonymousCallRejection&#34;)
        return self._anonymous_call_rejection

    @property
    def alternate_numbers(self):
        &#34;&#34;&#34;The Alternate Numbers for this Person&#34;&#34;&#34;
        if not self._alternate_numbers or not self._cache:
            self._alternate_numbers = \
                self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/AlternateNumbers&#34;)
        return self._alternate_numbers

    @property
    def profile(self):
        &#34;&#34;&#34;The XSI Profile for this Person&#34;&#34;&#34;
        if not self._profile or not self._cache:
            profile_data: dict = \
                self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/profile&#34;)
            # The following is a mapping of the raw XSI format to the profile attribute
            self._profile[&#39;registrations_url&#39;] = profile_data[&#39;Profile&#39;][&#39;registrations&#39;][&#39;$&#39;]
            self._profile[&#39;schedule_url&#39;] = profile_data[&#39;Profile&#39;][&#39;scheduleList&#39;][&#39;$&#39;]
            self._profile[&#39;fac_url&#39;] = profile_data[&#39;Profile&#39;][&#39;fac&#39;][&#39;$&#39;]
            self._profile[&#39;country_code&#39;] = profile_data[&#39;Profile&#39;][&#39;countryCode&#39;][&#39;$&#39;]
            self._profile[&#39;user_id&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;userId&#39;][&#39;$&#39;]
            self._profile[&#39;group_id&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;groupId&#39;][&#39;$&#39;]
            self._profile[&#39;service_provider&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;serviceProvider&#39;][&#39;$&#39;]
            # Not everyone has a number and/or extension, so we need to check to see if there are there
            if &#34;number&#34; in profile_data[&#39;Profile&#39;][&#39;details&#39;]:
                self._profile[&#39;number&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;number&#39;][&#39;$&#39;]
            if &#34;extension&#34; in profile_data[&#39;Profile&#39;][&#39;details&#39;]:
                self._profile[&#39;extension&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;extension&#39;][&#39;$&#39;]
        return self._profile

    @property
    def registrations(self):
        &#34;&#34;&#34;The device registrations associated with this Person&#34;&#34;&#34;
        if not self._registrations or not self._cache:
            # If we don&#39;t have a registrations URL, because we don&#39;t have the profile, go get it
            if &#34;registrations_url&#34; not in self._profile:
                self.profile
            self._registrations = self.__get_xsi_data(self._profile[&#39;registrations_url&#39;])
        return self._registrations

    def get_fac(self):
        # If we don&#39;t have a FAC URL, go get it
        if &#34;fac_url&#34; not in self._profile:
            self.profile()
        r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + self._profile[&#39;fac_url&#39;],
                         headers=self._headers, params=self._params)
        response = r.json()
        self.fac = response
        return self.fac

    def get_services(self):
        # TODO There are still some services that we should collect more data for. For example, BroadWorks
        #       Anywhere has Locations that aren&#39;t pulled without a separate call.

        r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + &#34;/v2.0/user/&#34; + self.id + &#34;/services&#34;,
                         headers=self._headers, params=self._params)
        response = r.json()
        self.services[&#39;list&#39;] = response[&#39;Services&#39;][&#39;service&#39;]
        # Now that we have all of the services, pulling the data is pretty easy since the URL
        # is present in the response. Loop through the services and collect the data
        # Some services have no config so there is no URI and we&#39;ll just populate them as True
        for service in self.services[&#39;list&#39;]:
            if &#34;uri&#34; in service:
                r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + service[&#39;uri&#39;][&#39;$&#39;],
                                 headers=self._headers, params=self._params)
                # Getting well-formatted JSON doesn&#39;t always work. If we can decode the JSON, use it
                # If not, just store the raw text. At some point, it would make sense to parse the text
                # and build the dict directly
                try:
                    response = r.json()
                except json.decoder.JSONDecodeError:
                    response = r.text
                self.services[service[&#39;name&#39;][&#39;$&#39;]] = response
            else:
                self.services[service[&#39;name&#39;][&#39;$&#39;]] = True
        return self.services


class HuntGroup:
    def __init__(self, parent: object,
                 id: str,
                 name: str,
                 location: str,
                 enabled: bool,
                 phone_number: str = None,
                 extension: str = None,
                 config: bool = True
                 ):
        &#34;&#34;&#34;
        Initialize a HuntGroup instance
        Args:
            parent (Org): The Org instance to which the Hunt Group belongs
            id (str): The Webex ID for the Hunt Group
            name (str): The name of the Hunt Group
            location (str): The Location ID associated with the Hunt Group
            enabled (bool): Boolean indicating whether the Hunt Group is enabled
            phone_number (str, optional): The DID for the Hunt Group
            extension (str, optional): The extension of the Hunt Group
        Returns:
            HuntGroup: The HuntGroup instance
        &#34;&#34;&#34;

        # Instance attrs
        self.parent: object = parent
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Hunt Group&#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;The name of the Hunt Group&#34;&#34;&#34;
        self.location: str = location
        &#34;&#34;&#34;The Location ID associated with the Hunt Group&#34;&#34;&#34;
        self.enabled: bool = enabled
        &#34;&#34;&#34;Whether the Hunt Group is enabled or not&#34;&#34;&#34;
        self.phone_number: str = phone_number
        &#34;&#34;&#34;The DID for the Hunt Group&#34;&#34;&#34;
        self.extension: str = extension
        &#34;&#34;&#34;The extension of the Hunt Group&#34;&#34;&#34;
        self.agents: list = []
        &#34;&#34;&#34;List of agents/users assigned to this Hunt Group&#34;&#34;&#34;
        self.distinctive_ring: bool = False
        &#34;&#34;&#34;Whether or not the Hunt Group has Distinctive Ring enabled&#34;&#34;&#34;
        self.alternate_numbers_settings: dict = {}
        &#34;&#34;&#34;List of alternate numbers for this Hunt Group&#34;&#34;&#34;
        self.language: str = &#34;&#34;
        &#34;&#34;&#34;The language name for the Hunt Group&#34;&#34;&#34;
        self.language_code: str = &#34;&#34;
        &#34;&#34;&#34;The short name for the language of the Hunt Group&#34;&#34;&#34;
        self.first_name: str = &#34;&#34;
        &#34;&#34;&#34;The Caller ID first name for the Hunt Group&#34;&#34;&#34;
        self.last_name: str = &#34;&#34;
        &#34;&#34;&#34;The Caller ID last name for the Hunt Group&#34;&#34;&#34;
        self.time_zone: str = &#34;&#34;
        &#34;&#34;&#34;The time zone for the Hunt Group&#34;&#34;&#34;
        self.call_policy: dict = {}
        &#34;&#34;&#34;The Call Policy for the Hunt Group&#34;&#34;&#34;
        self.agents: list = []
        &#34;&#34;&#34;List of users assigned to this Hunt Group&#34;&#34;&#34;
        self.raw_config: dict = {}
        &#34;&#34;&#34;The raw JSON-to-Python config from Webex&#34;&#34;&#34;

        # Get the config unless we are asked not to
        if config:
            logging.info(f&#34;Getting config for Hunt Group {self.id} in Location {self.location}&#34;)
            self.get_config()

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    def get_config(self):
        &#34;&#34;&#34;Get the Hunt Group config, including agents&#34;&#34;&#34;
        r = requests.get(_url_base + f&#34;v1/telephony/config/locations/{self.location}/huntGroups/{self.id}&#34;,
                         headers=self.parent._headers)
        response = r.json()
        self.raw_config = response
        self.agents = response[&#39;agents&#39;]
        self.distinctive_ring = response.get(&#34;distinctiveRing&#34;, False)
        self.alternate_numbers_settings = response[&#39;alternateNumberSettings&#39;]
        self.language = response[&#39;language&#39;]
        self.language_code = response[&#39;languageCode&#39;]
        self.first_name = response[&#39;firstName&#39;]
        self.last_name = response[&#39;lastName&#39;]
        self.time_zone = response[&#39;timeZone&#39;]
        self.call_policy = response[&#39;callPolicies&#39;]

        return self.raw_config


class Call:
    &#34;&#34;&#34;
    The Call class represents a call for a person. Since Webex supports calls in the Webex API as well as XSI API,
    the class supports both styles. When initialized, the parent instance is checked to see if it is a Person
    instance or an XSI instance. At the moment, the Webex API only supports user-scoped call control, so most of the
    development focus right now is the XSI API, which is more feature-rich
    &#34;&#34;&#34;

    def __init__(self, parent, id: str = &#34;&#34;, address: str = &#34;&#34;):
        &#34;&#34;&#34;
        Inititalize a Call instance for a Person
        Args:
            parent (XSI): The Person or XSI instance that owns this Call
            id (str, optional): The Call ID of a known call. Usually only done during a XSI.calls method
            address (str, optional): The address to originate a call to when the instance is created
        Returns:
            Call: This Call instance
        &#34;&#34;&#34;
        self._parent: XSI = parent
        &#34;&#34;&#34;The Person or XSI instance that owns this Call&#34;&#34;&#34;
        self._userid: str = self._parent.id
        &#34;&#34;&#34;The Person or XSI ID inherited from the parent&#34;&#34;&#34;
        self._headers = self._parent._headers
        self._params = self._parent._params
        self._url: str = &#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Call ID for this call&#34;&#34;&#34;
        self._external_tracking_id: str = &#34;&#34;
        &#34;&#34;&#34;The externalTrackingId used by XSI&#34;&#34;&#34;
        self._status: dict = {}
        &#34;&#34;&#34;The status of the call&#34;&#34;&#34;

        if type(self._parent) is Person:
            # This is where we set things based on whether the parent is a Person
            self._url = _url_base
            pass
        elif type(self._parent) is XSI:
            # The Call parent is XSI
            self._url = self._parent.xsi_endpoints[&#39;actions_endpoint&#39;] + f&#34;/v2.0/user/{self._userid}/calls&#34;
        elif type(self._parent) is Call:
            # Another Call created this Call instance (probably for a transfer or conference
            self._url = self._parent.xsi_endpoints[&#39;actions_endpoint&#39;] + f&#34;/v2.0/user/{self._parent._userid}/calls&#34;

        if address:
            self.originate(address)

    def originate(self, address: str, comment: str = &#34;&#34;):
        &#34;&#34;&#34;
        Originate a call on behalf of the Person
        Args:
            address (str): The address (usually a phone number) to originate the call to
            comment (str, optional): Text comment to attach to the call
        Returns:
            bool: Whether the command was successful
        &#34;&#34;&#34;
        logging.info(f&#34;Originating a call to {address} for {self._userid}&#34;)
        params = {&#34;address&#34;: address, &#34;info&#34;: comment}
        r = requests.post(self._url + &#34;/new&#34;, headers=self._headers, params=params)
        response = r.json()
        self.id = response[&#39;CallStartInfo&#39;][&#39;callId&#39;][&#39;$&#39;]
        self._external_tracking_id = response[&#39;CallStartInfo&#39;][&#39;externalTrackingId&#39;][&#39;$&#39;]
        if r.status_code == 201:
            return True
        else:
            return False

    def hangup(self):
        &#34;&#34;&#34;
        Hang up the call
        Returns:
            bool: Whether the command was successful
        &#34;&#34;&#34;
        logging.info(f&#34;Hanging up call ID: {self.id}&#34;)
        r = requests.delete(self._url + f&#34;/{self.id}&#34;,
                            headers=self._headers)
        if r.status_code == 200:
            return True
        else:
            return False

    @property
    def status(self):
        &#34;&#34;&#34;The status of the call

        Returns:
            dict:

                {
                &#39;network_call_id&#39; (str): The unique identifier for the Network side of the call
                &#39;personality&#39;(str): The user&#39;s personalty (Originator or Terminator)
                &#39;state&#39; (str): The state of the call
                &#39;remote_party&#39; (dict): {
                    &#39;address&#39; (str): The address of the remote party
                    &#39;call_type&#39; (str): The call type
                    }
                &#39;endpoint&#39; (dict): {
                    &#39;type&#39; (str): The type of endpoint in use
                    &#39;AoR&#39; (str): The Address of Record for the endpoint
                    }
                &#39;appearance&#39; (str): The Call Appearance number
                &#39;start_time&#39; (str): The UNIX timestanp of the start of the call
                &#39;answer_time&#39; (str): The UNIX timestamp when the call was answered
                &#39;status_time&#39; (str): The UNIX timestamp of the status response
                }

        &#34;&#34;&#34;
        logging.info(f&#34;Getting call status&#34;)
        r = requests.get(self._url + f&#34;/{self.id}&#34;,
                         headers=self._headers)
        response = r.json()
        logging.debug(f&#34;Call Status response: {response}&#34;)
        if r.status_code == 200:
            return_data = {
                &#34;network_call_id&#34;: response[&#39;Call&#39;][&#39;networkCallId&#39;][&#39;$&#39;],
                &#34;personality&#34;: response[&#39;Call&#39;][&#39;personality&#39;][&#39;$&#39;],
                &#34;state&#34;: response[&#39;Call&#39;][&#39;state&#39;][&#39;$&#39;],
                &#34;remote_party&#34;: {
                    &#34;address&#34;: response[&#39;Call&#39;][&#39;remoteParty&#39;][&#39;address&#39;][&#39;$&#39;],
                    &#34;call_type&#34;: response[&#39;Call&#39;][&#39;remoteParty&#39;][&#39;callType&#39;][&#39;$&#39;],
                },
                &#34;endpoint&#34;: {
                    &#34;type&#34;: response[&#39;Call&#39;][&#39;endpoint&#39;][&#39;@xsi1:type&#39;],
                    &#34;AoR&#34;: response[&#39;Call&#39;][&#39;endpoint&#39;][&#39;addressOfRecord&#39;][&#39;$&#39;]
                },
                &#34;appearance&#34;: response[&#39;Call&#39;][&#39;appearance&#39;][&#39;$&#39;],
                &#34;diversion_inhibited&#34;: response[&#39;Call&#39;][&#39;diversionInhibited&#39;],
                &#34;start_time&#34;: response[&#39;Call&#39;][&#39;startTime&#39;][&#39;$&#39;],
                &#34;answer_time&#34;: response[&#39;Call&#39;][&#39;answerTime&#39;][&#39;$&#39;],
                &#34;status_time&#34;: int(time.time())
            }
            return return_data
        else:
            return False

    def transfer(self, address: str, type: str = &#34;blind&#34;):
        &#34;&#34;&#34;Transfer the call to the selected address.

        Type of transfer can be controlled with `type` param. VM transfers will transfer the call directly to the voice
        mail of the address, even if the address is the user&#39;s own address. Attended transfers require a subsequent call
        to `finish_transfer()` when the actual transfer should happen.

        Args:
            address (str): The address (usually a phone number or extension) to transfer the call to
            type (str): [&#39;blind&#39;,&#39;vm&#39;,&#39;attended&#39;]:
                The type of transfer.

        Returns:
            bool: True if successful. False if unsuccessful

        &#34;&#34;&#34;
        logging.info(f&#34;Transferring call {self.id} to {address} for {self._userid}&#34;)
        # Set the address param to be passed to XSI
        params = {&#34;address&#34;: address}
        # Handle an attended transfer first. Anything else is assumed to be blind
        if type.lower() == &#34;attended&#34;:
            # Attended transfer requires the first call to be put on hold and the second call to be
            # placed, so those are here. A separate call to finish_transfer will be required when the transfer should
            # happen.
            self.hold()
            self._transfer_call = self._parent.new_call()
            self._transfer_call.originate(address)
            return True
        elif type.lower() == &#34;vm&#34;:
            r = requests.put(self._url + f&#34;/{self.id}/VmTransfer&#34;, headers=self._headers, params=params)
            if r.status_code in [200, 201, 204]:
                return True
            else:
                return False
        else:
            r = requests.put(self._url + f&#34;/{self.id}/BlindTransfer&#34;, headers=self._headers, params=params)
            if r.status_code in [200, 201, 204]:
                return True
            else:
                return False

    def finish_transfer(self):
        &#34;&#34;&#34;
        Complete an Attended Transfer. This method will only complete if a `transfer(address, type=&#34;attended&#34;)`
        has been done first.

        Returns:
            bool: Whether or not the transfer completes

        &#34;&#34;&#34;
        logging.info(&#34;Completing transfer...&#34;)
        r = requests.put(self._url + f&#34;/{self.id}/ConsultTransfer/{self._transfer_call.id}&#34;, headers=self._headers)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False, r.text

    def conference(self, address: str = &#34;&#34;):
        &#34;&#34;&#34;
        Starts a multi-party conference. If the call is already held and an attended transfer is in progress,
        meaning the user is already talking to the transfer-to user, this method will bridge the calls.

        Args:
            address (str, optional): The address (usually a phone number or extension) to conference to. Not needed
                when the call is already part of an Attended Transfer

        Returns:
            bool: True if the conference is successful

        &#34;&#34;&#34;
        # First, check to see if the call is already part of an attended transfer. If so, just build the conference
        # based on the two call IDs
        if self._transfer_call:
            xml = f&#34;&lt;?xml version=\&#34;1.0\&#34; encoding=\&#34;UTF-8\&#34;?&gt;&#34; \
                  f&#34;&lt;Conference xmlns=\&#34;http://schema.broadsoft.com/xsi\&#34;&gt;&#34; \
                  f&#34;&lt;conferenceParticipantList&gt;&#34; \
                  f&#34;&lt;conferenceParticipant&gt;&#34; \
                  f&#34;&lt;callId&gt;{self.id}&lt;/callId&gt;&#34; \
                  f&#34;&lt;/conferenceParticipant&gt;&#34; \
                  f&#34;&lt;conferenceParticipant&gt;&#34; \
                  f&#34;&lt;callId&gt;{self._transfer_call.id}&lt;/callId&gt;&#34; \
                  f&#34;&lt;/conferenceParticipant&gt;&#34; \
                  f&#34;&lt;/conferenceParticipantList&gt;&#34; \
                  f&#34;&lt;/Conference&gt;&#34;
            # Building the XML by hand for right now. Probably going to replace it with something JSON-friendly
            headers = self._headers
            headers[&#39;Content-Type&#39;] = &#34;application/xml; charset=UTF-8&#34;
            r = requests.post(self._url + f&#34;/Conference&#34;, headers=headers, data=xml)
            if r.status_code in [200, 201, 204]:
                return self._parent.new_conference([self.id, self._transfer_call.id])
            else:
                return False
        else:
            # Still needs work.
            pass

    def send_dtmf(self, dtmf: str):
        &#34;&#34;&#34;Transmit DTMF tones outbound

        Args:
            dtmf (str): The string of dtmf digits to send. Accepted digits 0-9, star, pound. A comma will pause
                between digits (i.e. &#34;23456#,123&#34;)

        Returns:
            bool: True if the dtmf was sent successfully
        &#34;&#34;&#34;
        params = {&#34;playdtmf&#34;: str(dtmf)}
        r = requests.put(self._url + f&#34;/{self.id}/TransmitDTMF&#34;, headers=self._headers, params=params)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False, r.text

    def hold(self):
        &#34;&#34;&#34;Place the call on hold

        Returns:
            bool: Whether the hold command was successful

        &#34;&#34;&#34;
        r = requests.put(self._url + f&#34;/{self.id}/Hold&#34;, headers=self._headers)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False

    def resume(self):
        &#34;&#34;&#34;Resume a call that was placed on hold

        Returns:
            bool: Whether the command was successful

        &#34;&#34;&#34;
        r = requests.put(self._url + f&#34;/{self.id}/Talk&#34;, headers=self._headers)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False


class Conference:
    &#34;&#34;&#34;The class for Conference Calls started by a Call.conference()&#34;&#34;&#34;

    def __init__(self, parent: object, calls: list, comment: str = &#34;&#34;):
        &#34;&#34;&#34;Initialize a Conference instance for an XSI instance

        Args:
            parent (XSI): The XSI instance that owns this conference
            calls (list): Call IDs associated with the Conference. Always two Call IDs to start a Conference.
                Any additional Call IDs will be added to the conference as it is created.
            comment (str, optional): An optional text comment for the Conference

        Returns:
            Conference: This instance of the Conference class

        &#34;&#34;&#34;
        self._parent: XSI = parent
        self._calls: list = calls
        self._userid = self._parent.id
        self._headers = self._parent._headers
        self._url = self._parent.xsi_endpoints[&#39;actions_endpoint&#39;] + f&#34;/v2.0/user/{self._userid}/calls/Conference&#34;
        self.comment: str = comment
        &#34;&#34;&#34;Text comment associated with the Conference&#34;&#34;&#34;

    def deaf(self, call: str):
        &#34;&#34;&#34;Stop audio and video from being sent to a participant. Audio and video from that participant are unaffected.

        Args:
            call (str): The Call ID to make deaf

        Returns:
            bool: Whether the command was successful

        &#34;&#34;&#34;
        pass


class Workspace:
    def __init__(self, parent: Org, id: str, config: dict = None):
        &#34;&#34;&#34;Initialize a Workspace instance. If only the `id` is provided, the configuration will be fetched from
            the Webex API. To save API calls, the config dict can be passed using the `config` argument
        Args:
            parent (Org): The Organization to which this workspace belongs
            id (str): The Webex ID of the Workspace
            config (dict): The configuration of the Workspace as returned by the Webex API
        &#34;&#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Workspace&#34;&#34;&#34;
        self._parent: Org = parent
        # Attributes inherited from the Org parent
        self._headers = self._parent._headers
        self._params = self._parent._params
        # Instance attributes
        self.location: str = None
        &#34;&#34;&#34;The Webex ID of the Workspace Location (note this is a Workspace Location, not a Calling Location.&#34;&#34;&#34;
        self.floor: str = None
        &#34;&#34;&#34;The Webex ID of the Floor ID&#34;&#34;&#34;
        self.name: str = &#34;&#34;
        &#34;&#34;&#34;The name of the Workspace&#34;&#34;&#34;
        self.capacity: int = None
        &#34;&#34;&#34;The capacity of the Workspace&#34;&#34;&#34;
        self.type: str = None
        &#34;&#34;&#34;
        The type of Workspace. Valid values are:
        
            &#34;notSet&#34;: No value set
            &#34;focus&#34;: High concentration
            &#34;huddle&#34;: Brainstorm/collaboration
            &#34;meetingRoom&#34;: Dedicated meeting space
            &#34;open&#34;: Unstructured agile
            &#34;desk&#34;: Individual
            &#34;other&#34;: Unspecified
        &#34;&#34;&#34;
        self.sip_address: str = None
        &#34;&#34;&#34;The SIP Address used to call to the Workspace&#34;&#34;&#34;
        self.created: str = None
        &#34;&#34;&#34;The date and time the workspace was created&#34;&#34;&#34;
        self.calling: str = None
        &#34;&#34;&#34;
        The type of Calling license assigned to the Workspace. Valid values are:
        
            &#39;freeCalling&#39;: Free Calling
            &#39;hybridCalling&#39;: Hybrid Calling
            &#39;webexCalling&#39;: Webex Calling
            &#39;webexEdgeForDevices&#39;: Webex Edge for Devices
        &#34;&#34;&#34;
        self.calendar: dict = None
        &#34;&#34;&#34;The type of calendar connector assigned to the Workspace&#34;&#34;&#34;
        self.notes: str = None
        &#34;&#34;&#34;Notes associated with the Workspace&#34;&#34;&#34;

        if config:
            self.__process_config(config)
        else:
            self.get_config()

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    @property
    def spark_id(self):
        bytes = base64.b64decode(self.id + &#34;===&#34;)
        spark_id = bytes.decode(&#34;utf-8&#34;)
        return spark_id

    def get_config(self):
        &#34;&#34;&#34;Get (or refresh) the confirmation of the Workspace from the Webex API&#34;&#34;&#34;
        logging.info(f&#34;Getting Workspace config for {self.id}&#34;)
        r = requests.get(_url_base + f&#34;v1/workspaces/{self.id}&#34;, headers=self._headers, params=self._params)
        if r.status_code in [200]:
            response = r.json()
            self.__process_config(response)
        else:
            raise APIError(f&#34;Unable to fetch workspace config for {self.id}&#34;)

    def __process_config(self, config: dict):
        &#34;&#34;&#34;Processes the config dict, whether passed in init or from an API call&#34;&#34;&#34;
        self.name = config.get(&#34;displayName&#34;, &#34;&#34;)
        self.location = config.get(&#34;workspaceLocationId&#34;, &#34;&#34;)
        self.floor = config.get(&#34;floorId&#34;, &#34;&#34;)
        self.capacity = config.get(&#34;capacity&#34;, 0)
        self.type = config[&#39;type&#39;]
        self.sip_address = config.get(&#34;sipAddress&#34;, &#34;&#34;)
        self.created = config.get(&#34;created&#34;, &#34;&#34;)
        if &#34;calling&#34; in config:
            self.calling = config[&#39;calling&#39;][&#39;type&#39;]
        else:
            self.calling = &#34;None&#34;
        self.calendar = config[&#39;calendar&#39;]
        self.notes = config.get(&#34;notes&#34;, &#34;&#34;)


class WorkspaceLocation:
    def __init__(self, parent: Org, id: str, config: dict = None):
        &#34;&#34;&#34;Initialize a WorkspaceLocation instance.

        If only the `id` is provided, the configuration will be fetched from
            the Webex API. To save API calls, the config dict can be passed using the `config` argument

        Args:
            parent (Org): The Organization to which this WorkspaceLocation belongs
            id (str): The Webex ID of the WorkspaceLocation
            config (dict): The configuration of the WorkspaceLocation as returned by the Webex API

        &#34;&#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Workspace&#34;&#34;&#34;
        self._parent: Org = parent
        # Attributes inherited from the Org parent
        self._headers = self._parent._headers
        self._params = self._parent._params
        # Instance attributes
        self.name: str = None
        &#34;&#34;&#34;The name of the WorkspaceLocation&#34;&#34;&#34;
        self.address: str = None
        &#34;&#34;&#34;The address of the WorkspaceLocation&#34;&#34;&#34;
        self.country: str = None
        &#34;&#34;&#34;The country code (ISO 3166-1) for the WorkspaceLocation&#34;&#34;&#34;
        self.city: str = None
        &#34;&#34;&#34;The city name where the WorkspaceLocation is located&#34;&#34;&#34;
        self.latitude: float = None
        &#34;&#34;&#34;The WorkspaceLocation latitude&#34;&#34;&#34;
        self.longitude: float = None
        &#34;&#34;&#34;The WorkspaceLocation longitude&#34;&#34;&#34;
        self.notes: str = None
        &#34;&#34;&#34;Notes associated with the WorkspaceLocation&#34;&#34;&#34;
        self.floors: list[WorkspaceLocationFloor] = None

        if config:
            self.__process_config(config)
        else:
            self.get_config()
        self.get_floors()

    def get_config(self):
        &#34;&#34;&#34;Get (or refresh) the configuration of the WorkspaceLocations from the Webex API&#34;&#34;&#34;
        logging.info(f&#34;Getting Workspace config for {self.id}&#34;)
        r = requests.get(_url_base + f&#34;v1/workspaceLocations/{self.id}&#34;, headers=self._headers, params=self._params)
        if r.status_code in [200]:
            response = r.json()
            self.__process_config(response)
        else:
            raise APIError(f&#34;Unable to fetch workspace config for {self.id}&#34;)

    def get_floors(self):
        &#34;&#34;&#34;Get (or refresh) the WorkspaceLocationFloor instances for this WorkspaceLocation&#34;&#34;&#34;
        logging.info(f&#34;Getting Location Floors for {self.name}&#34;)
        self.floors = []
        r = requests.get(_url_base + f&#34;v1/workspaceLocations/{self.id}/floors&#34;,
                         headers=self._headers, params=self._params)
        response = r.json()
        for floor in response[&#39;items&#39;]:
            this_floor = WorkspaceLocationFloor(floor)
            self.floors.append(this_floor)

    def __process_config(self, config: dict):
        &#34;&#34;&#34;Processes the config dict, whether passed in init or from an API call&#34;&#34;&#34;
        self.name = config.get(&#34;displayName&#34;, &#34;&#34;)
        self.address = config.get(&#34;address&#34;, &#34;&#34;)
        self.country = config.get(&#34;countryCode&#34;, &#34;&#34;)
        self.city = config.get(&#34;cityName&#34;, &#34;&#34;)
        self.latitude = config.get(&#34;latitude&#34;, &#34;&#34;)
        self.longitude = config.get(&#34;longitude&#34;, &#34;&#34;)
        self.notes = config.get(&#34;notes&#34;, &#34;&#34;)


class WorkspaceLocationFloor(WorkspaceLocation):
    def __init__(self, config: dict):
        &#34;&#34;&#34;Initialize a new WorkspaceLocationFloor

        Args:
            config (dict): The config as returned by the Webex API

        &#34;&#34;&#34;
        self.name = config.get(&#34;displayName&#34;)
        self.id = config.get(&#34;id&#34;)
        self.floor = config.get(&#34;floorNumber&#34;)


class CPAPI:
    &#34;&#34;&#34;The CPAPI class handles API calls using the CP-API, which is the native API used by Webex Control Hub.&#34;&#34;&#34;

    def __init__(self, org: Org, access_token: str):
        self._access_token = access_token
        self._headers = {&#34;Authorization&#34;: f&#34;Bearer {access_token}&#34;}

        # Calculate the &#34;customer&#34; ID from the Org ID
        org_id_bytes = base64.b64decode(org.id + &#34;===&#34;)
        org_id_decoded = org_id_bytes.decode(&#34;utf-8&#34;)
        self._customer = org_id_decoded.split(&#34;/&#34;)[-1]

        self._url_base = f&#34;https://cpapi-a.wbx2.com/api/v1/customers/{self._customer}/&#34;

    def set_global_vm_pin(self, pin: str):
        &#34;&#34;&#34;Set the Org-wide default VM PIN

        Args:
            pin (str): The PIN to set as the global default

        Returns:
            bool: True is successful

        Raises:
            ValueError: Raised when the PIN value is rejected by Webex, usually because the PIN doesn&#39;t comply
                with the security policy.

        &#34;&#34;&#34;
        logging.info(&#34;Setting Org-wide default VM PIN&#34;)
        payload = {
            &#34;defaultVoicemailPinEnabled&#34;: True,
            &#34;defaultVoicemailPin&#34;: str(pin)
        }
        r = requests.patch(self._url_base + &#34;features/voicemail/rules&#34;,
                           headers=self._headers, json=payload)
        return r.text

    def clear_global_vm_pin(self):
        logging.info(&#34;Clearing Org-wide default VM PIN&#34;)
        payload = {
            &#34;defaultVoicemailPinEnabled&#34;: False,
        }
        r = requests.patch(self._url_base + f&#34;features/voicemail/rules&#34;,
                           headers=self._headers, json=payload)
        return r.text

    def reset_vm_pin(self, person: Person, pin: str = None):
        logging.info(f&#34;Resetting VM PIN for {person.email}&#34;)
        user_id = person.spark_id.split(&#34;/&#34;)[-1]

        if pin is not None:
            self.set_global_vm_pin(pin)

        requests.post(self._url_base + f&#34;users/{user_id}/features/voicemail/actions/resetpin/invoke&#34;,
                      headers=self._headers)

        if pin is not None:
            self.clear_global_vm_pin()

        return True

    def get_numbers(self):
        numbers = []
        r = requests.get(self._url_base + f&#34;numbers&#34;, headers=self._headers)
        if r.status_code == 200:
            response = r.json()
            for number in response[&#39;numbers&#39;]:
                if &#34;owner&#34; in number:
                    user_str = f&#34;ciscospark://us/PEOPLE/{number[&#39;owner&#39;][&#39;id&#39;]}&#34;
                    user_bytes = user_str.encode(&#34;utf-8&#34;)
                    base64_bytes = base64.b64encode(user_bytes)
                    base64_id = base64_bytes.decode(&#39;utf-8&#39;)
                    base64_id = base64_id.rstrip(&#34;=&#34;)
                    number[&#39;owner&#39;][&#39;id&#39;] = base64_id

                numbers.append(number)
            # Get the pagination for future use
            pagination = response[&#39;paging&#39;]
            return numbers
        else:
            return r.text</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wxcadm.CPAPI"><code class="flex name class">
<span>class <span class="ident">CPAPI</span></span>
<span>(</span><span>org:<a title="wxcadm.Org" href="#wxcadm.Org">Org</a>, access_token:str)</span>
</code></dt>
<dd>
<div class="desc"><p>The CPAPI class handles API calls using the CP-API, which is the native API used by Webex Control Hub.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CPAPI:
    &#34;&#34;&#34;The CPAPI class handles API calls using the CP-API, which is the native API used by Webex Control Hub.&#34;&#34;&#34;

    def __init__(self, org: Org, access_token: str):
        self._access_token = access_token
        self._headers = {&#34;Authorization&#34;: f&#34;Bearer {access_token}&#34;}

        # Calculate the &#34;customer&#34; ID from the Org ID
        org_id_bytes = base64.b64decode(org.id + &#34;===&#34;)
        org_id_decoded = org_id_bytes.decode(&#34;utf-8&#34;)
        self._customer = org_id_decoded.split(&#34;/&#34;)[-1]

        self._url_base = f&#34;https://cpapi-a.wbx2.com/api/v1/customers/{self._customer}/&#34;

    def set_global_vm_pin(self, pin: str):
        &#34;&#34;&#34;Set the Org-wide default VM PIN

        Args:
            pin (str): The PIN to set as the global default

        Returns:
            bool: True is successful

        Raises:
            ValueError: Raised when the PIN value is rejected by Webex, usually because the PIN doesn&#39;t comply
                with the security policy.

        &#34;&#34;&#34;
        logging.info(&#34;Setting Org-wide default VM PIN&#34;)
        payload = {
            &#34;defaultVoicemailPinEnabled&#34;: True,
            &#34;defaultVoicemailPin&#34;: str(pin)
        }
        r = requests.patch(self._url_base + &#34;features/voicemail/rules&#34;,
                           headers=self._headers, json=payload)
        return r.text

    def clear_global_vm_pin(self):
        logging.info(&#34;Clearing Org-wide default VM PIN&#34;)
        payload = {
            &#34;defaultVoicemailPinEnabled&#34;: False,
        }
        r = requests.patch(self._url_base + f&#34;features/voicemail/rules&#34;,
                           headers=self._headers, json=payload)
        return r.text

    def reset_vm_pin(self, person: Person, pin: str = None):
        logging.info(f&#34;Resetting VM PIN for {person.email}&#34;)
        user_id = person.spark_id.split(&#34;/&#34;)[-1]

        if pin is not None:
            self.set_global_vm_pin(pin)

        requests.post(self._url_base + f&#34;users/{user_id}/features/voicemail/actions/resetpin/invoke&#34;,
                      headers=self._headers)

        if pin is not None:
            self.clear_global_vm_pin()

        return True

    def get_numbers(self):
        numbers = []
        r = requests.get(self._url_base + f&#34;numbers&#34;, headers=self._headers)
        if r.status_code == 200:
            response = r.json()
            for number in response[&#39;numbers&#39;]:
                if &#34;owner&#34; in number:
                    user_str = f&#34;ciscospark://us/PEOPLE/{number[&#39;owner&#39;][&#39;id&#39;]}&#34;
                    user_bytes = user_str.encode(&#34;utf-8&#34;)
                    base64_bytes = base64.b64encode(user_bytes)
                    base64_id = base64_bytes.decode(&#39;utf-8&#39;)
                    base64_id = base64_id.rstrip(&#34;=&#34;)
                    number[&#39;owner&#39;][&#39;id&#39;] = base64_id

                numbers.append(number)
            # Get the pagination for future use
            pagination = response[&#39;paging&#39;]
            return numbers
        else:
            return r.text</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.CPAPI.clear_global_vm_pin"><code class="name flex">
<span>def <span class="ident">clear_global_vm_pin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_global_vm_pin(self):
    logging.info(&#34;Clearing Org-wide default VM PIN&#34;)
    payload = {
        &#34;defaultVoicemailPinEnabled&#34;: False,
    }
    r = requests.patch(self._url_base + f&#34;features/voicemail/rules&#34;,
                       headers=self._headers, json=payload)
    return r.text</code></pre>
</details>
</dd>
<dt id="wxcadm.CPAPI.get_numbers"><code class="name flex">
<span>def <span class="ident">get_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_numbers(self):
    numbers = []
    r = requests.get(self._url_base + f&#34;numbers&#34;, headers=self._headers)
    if r.status_code == 200:
        response = r.json()
        for number in response[&#39;numbers&#39;]:
            if &#34;owner&#34; in number:
                user_str = f&#34;ciscospark://us/PEOPLE/{number[&#39;owner&#39;][&#39;id&#39;]}&#34;
                user_bytes = user_str.encode(&#34;utf-8&#34;)
                base64_bytes = base64.b64encode(user_bytes)
                base64_id = base64_bytes.decode(&#39;utf-8&#39;)
                base64_id = base64_id.rstrip(&#34;=&#34;)
                number[&#39;owner&#39;][&#39;id&#39;] = base64_id

            numbers.append(number)
        # Get the pagination for future use
        pagination = response[&#39;paging&#39;]
        return numbers
    else:
        return r.text</code></pre>
</details>
</dd>
<dt id="wxcadm.CPAPI.reset_vm_pin"><code class="name flex">
<span>def <span class="ident">reset_vm_pin</span></span>(<span>self, person:<a title="wxcadm.Person" href="#wxcadm.Person">Person</a>, pin:str=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_vm_pin(self, person: Person, pin: str = None):
    logging.info(f&#34;Resetting VM PIN for {person.email}&#34;)
    user_id = person.spark_id.split(&#34;/&#34;)[-1]

    if pin is not None:
        self.set_global_vm_pin(pin)

    requests.post(self._url_base + f&#34;users/{user_id}/features/voicemail/actions/resetpin/invoke&#34;,
                  headers=self._headers)

    if pin is not None:
        self.clear_global_vm_pin()

    return True</code></pre>
</details>
</dd>
<dt id="wxcadm.CPAPI.set_global_vm_pin"><code class="name flex">
<span>def <span class="ident">set_global_vm_pin</span></span>(<span>self, pin:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the Org-wide default VM PIN</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pin</code></strong> :&ensp;<code>str</code></dt>
<dd>The PIN to set as the global default</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True is successful</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised when the PIN value is rejected by Webex, usually because the PIN doesn't comply
with the security policy.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_global_vm_pin(self, pin: str):
    &#34;&#34;&#34;Set the Org-wide default VM PIN

    Args:
        pin (str): The PIN to set as the global default

    Returns:
        bool: True is successful

    Raises:
        ValueError: Raised when the PIN value is rejected by Webex, usually because the PIN doesn&#39;t comply
            with the security policy.

    &#34;&#34;&#34;
    logging.info(&#34;Setting Org-wide default VM PIN&#34;)
    payload = {
        &#34;defaultVoicemailPinEnabled&#34;: True,
        &#34;defaultVoicemailPin&#34;: str(pin)
    }
    r = requests.patch(self._url_base + &#34;features/voicemail/rules&#34;,
                       headers=self._headers, json=payload)
    return r.text</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.Call"><code class="flex name class">
<span>class <span class="ident">Call</span></span>
<span>(</span><span>parent, id:str='', address:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>The Call class represents a call for a person. Since Webex supports calls in the Webex API as well as XSI API,
the class supports both styles. When initialized, the parent instance is checked to see if it is a Person
instance or an XSI instance. At the moment, the Webex API only supports user-scoped call control, so most of the
development focus right now is the XSI API, which is more feature-rich</p>
<p>Inititalize a Call instance for a Person</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="wxcadm.XSI" href="#wxcadm.XSI">XSI</a></code></dt>
<dd>The Person or XSI instance that owns this Call</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The Call ID of a known call. Usually only done during a XSI.calls method</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The address to originate a call to when the instance is created</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Call" href="#wxcadm.Call">Call</a></code></dt>
<dd>This Call instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Call:
    &#34;&#34;&#34;
    The Call class represents a call for a person. Since Webex supports calls in the Webex API as well as XSI API,
    the class supports both styles. When initialized, the parent instance is checked to see if it is a Person
    instance or an XSI instance. At the moment, the Webex API only supports user-scoped call control, so most of the
    development focus right now is the XSI API, which is more feature-rich
    &#34;&#34;&#34;

    def __init__(self, parent, id: str = &#34;&#34;, address: str = &#34;&#34;):
        &#34;&#34;&#34;
        Inititalize a Call instance for a Person
        Args:
            parent (XSI): The Person or XSI instance that owns this Call
            id (str, optional): The Call ID of a known call. Usually only done during a XSI.calls method
            address (str, optional): The address to originate a call to when the instance is created
        Returns:
            Call: This Call instance
        &#34;&#34;&#34;
        self._parent: XSI = parent
        &#34;&#34;&#34;The Person or XSI instance that owns this Call&#34;&#34;&#34;
        self._userid: str = self._parent.id
        &#34;&#34;&#34;The Person or XSI ID inherited from the parent&#34;&#34;&#34;
        self._headers = self._parent._headers
        self._params = self._parent._params
        self._url: str = &#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Call ID for this call&#34;&#34;&#34;
        self._external_tracking_id: str = &#34;&#34;
        &#34;&#34;&#34;The externalTrackingId used by XSI&#34;&#34;&#34;
        self._status: dict = {}
        &#34;&#34;&#34;The status of the call&#34;&#34;&#34;

        if type(self._parent) is Person:
            # This is where we set things based on whether the parent is a Person
            self._url = _url_base
            pass
        elif type(self._parent) is XSI:
            # The Call parent is XSI
            self._url = self._parent.xsi_endpoints[&#39;actions_endpoint&#39;] + f&#34;/v2.0/user/{self._userid}/calls&#34;
        elif type(self._parent) is Call:
            # Another Call created this Call instance (probably for a transfer or conference
            self._url = self._parent.xsi_endpoints[&#39;actions_endpoint&#39;] + f&#34;/v2.0/user/{self._parent._userid}/calls&#34;

        if address:
            self.originate(address)

    def originate(self, address: str, comment: str = &#34;&#34;):
        &#34;&#34;&#34;
        Originate a call on behalf of the Person
        Args:
            address (str): The address (usually a phone number) to originate the call to
            comment (str, optional): Text comment to attach to the call
        Returns:
            bool: Whether the command was successful
        &#34;&#34;&#34;
        logging.info(f&#34;Originating a call to {address} for {self._userid}&#34;)
        params = {&#34;address&#34;: address, &#34;info&#34;: comment}
        r = requests.post(self._url + &#34;/new&#34;, headers=self._headers, params=params)
        response = r.json()
        self.id = response[&#39;CallStartInfo&#39;][&#39;callId&#39;][&#39;$&#39;]
        self._external_tracking_id = response[&#39;CallStartInfo&#39;][&#39;externalTrackingId&#39;][&#39;$&#39;]
        if r.status_code == 201:
            return True
        else:
            return False

    def hangup(self):
        &#34;&#34;&#34;
        Hang up the call
        Returns:
            bool: Whether the command was successful
        &#34;&#34;&#34;
        logging.info(f&#34;Hanging up call ID: {self.id}&#34;)
        r = requests.delete(self._url + f&#34;/{self.id}&#34;,
                            headers=self._headers)
        if r.status_code == 200:
            return True
        else:
            return False

    @property
    def status(self):
        &#34;&#34;&#34;The status of the call

        Returns:
            dict:

                {
                &#39;network_call_id&#39; (str): The unique identifier for the Network side of the call
                &#39;personality&#39;(str): The user&#39;s personalty (Originator or Terminator)
                &#39;state&#39; (str): The state of the call
                &#39;remote_party&#39; (dict): {
                    &#39;address&#39; (str): The address of the remote party
                    &#39;call_type&#39; (str): The call type
                    }
                &#39;endpoint&#39; (dict): {
                    &#39;type&#39; (str): The type of endpoint in use
                    &#39;AoR&#39; (str): The Address of Record for the endpoint
                    }
                &#39;appearance&#39; (str): The Call Appearance number
                &#39;start_time&#39; (str): The UNIX timestanp of the start of the call
                &#39;answer_time&#39; (str): The UNIX timestamp when the call was answered
                &#39;status_time&#39; (str): The UNIX timestamp of the status response
                }

        &#34;&#34;&#34;
        logging.info(f&#34;Getting call status&#34;)
        r = requests.get(self._url + f&#34;/{self.id}&#34;,
                         headers=self._headers)
        response = r.json()
        logging.debug(f&#34;Call Status response: {response}&#34;)
        if r.status_code == 200:
            return_data = {
                &#34;network_call_id&#34;: response[&#39;Call&#39;][&#39;networkCallId&#39;][&#39;$&#39;],
                &#34;personality&#34;: response[&#39;Call&#39;][&#39;personality&#39;][&#39;$&#39;],
                &#34;state&#34;: response[&#39;Call&#39;][&#39;state&#39;][&#39;$&#39;],
                &#34;remote_party&#34;: {
                    &#34;address&#34;: response[&#39;Call&#39;][&#39;remoteParty&#39;][&#39;address&#39;][&#39;$&#39;],
                    &#34;call_type&#34;: response[&#39;Call&#39;][&#39;remoteParty&#39;][&#39;callType&#39;][&#39;$&#39;],
                },
                &#34;endpoint&#34;: {
                    &#34;type&#34;: response[&#39;Call&#39;][&#39;endpoint&#39;][&#39;@xsi1:type&#39;],
                    &#34;AoR&#34;: response[&#39;Call&#39;][&#39;endpoint&#39;][&#39;addressOfRecord&#39;][&#39;$&#39;]
                },
                &#34;appearance&#34;: response[&#39;Call&#39;][&#39;appearance&#39;][&#39;$&#39;],
                &#34;diversion_inhibited&#34;: response[&#39;Call&#39;][&#39;diversionInhibited&#39;],
                &#34;start_time&#34;: response[&#39;Call&#39;][&#39;startTime&#39;][&#39;$&#39;],
                &#34;answer_time&#34;: response[&#39;Call&#39;][&#39;answerTime&#39;][&#39;$&#39;],
                &#34;status_time&#34;: int(time.time())
            }
            return return_data
        else:
            return False

    def transfer(self, address: str, type: str = &#34;blind&#34;):
        &#34;&#34;&#34;Transfer the call to the selected address.

        Type of transfer can be controlled with `type` param. VM transfers will transfer the call directly to the voice
        mail of the address, even if the address is the user&#39;s own address. Attended transfers require a subsequent call
        to `finish_transfer()` when the actual transfer should happen.

        Args:
            address (str): The address (usually a phone number or extension) to transfer the call to
            type (str): [&#39;blind&#39;,&#39;vm&#39;,&#39;attended&#39;]:
                The type of transfer.

        Returns:
            bool: True if successful. False if unsuccessful

        &#34;&#34;&#34;
        logging.info(f&#34;Transferring call {self.id} to {address} for {self._userid}&#34;)
        # Set the address param to be passed to XSI
        params = {&#34;address&#34;: address}
        # Handle an attended transfer first. Anything else is assumed to be blind
        if type.lower() == &#34;attended&#34;:
            # Attended transfer requires the first call to be put on hold and the second call to be
            # placed, so those are here. A separate call to finish_transfer will be required when the transfer should
            # happen.
            self.hold()
            self._transfer_call = self._parent.new_call()
            self._transfer_call.originate(address)
            return True
        elif type.lower() == &#34;vm&#34;:
            r = requests.put(self._url + f&#34;/{self.id}/VmTransfer&#34;, headers=self._headers, params=params)
            if r.status_code in [200, 201, 204]:
                return True
            else:
                return False
        else:
            r = requests.put(self._url + f&#34;/{self.id}/BlindTransfer&#34;, headers=self._headers, params=params)
            if r.status_code in [200, 201, 204]:
                return True
            else:
                return False

    def finish_transfer(self):
        &#34;&#34;&#34;
        Complete an Attended Transfer. This method will only complete if a `transfer(address, type=&#34;attended&#34;)`
        has been done first.

        Returns:
            bool: Whether or not the transfer completes

        &#34;&#34;&#34;
        logging.info(&#34;Completing transfer...&#34;)
        r = requests.put(self._url + f&#34;/{self.id}/ConsultTransfer/{self._transfer_call.id}&#34;, headers=self._headers)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False, r.text

    def conference(self, address: str = &#34;&#34;):
        &#34;&#34;&#34;
        Starts a multi-party conference. If the call is already held and an attended transfer is in progress,
        meaning the user is already talking to the transfer-to user, this method will bridge the calls.

        Args:
            address (str, optional): The address (usually a phone number or extension) to conference to. Not needed
                when the call is already part of an Attended Transfer

        Returns:
            bool: True if the conference is successful

        &#34;&#34;&#34;
        # First, check to see if the call is already part of an attended transfer. If so, just build the conference
        # based on the two call IDs
        if self._transfer_call:
            xml = f&#34;&lt;?xml version=\&#34;1.0\&#34; encoding=\&#34;UTF-8\&#34;?&gt;&#34; \
                  f&#34;&lt;Conference xmlns=\&#34;http://schema.broadsoft.com/xsi\&#34;&gt;&#34; \
                  f&#34;&lt;conferenceParticipantList&gt;&#34; \
                  f&#34;&lt;conferenceParticipant&gt;&#34; \
                  f&#34;&lt;callId&gt;{self.id}&lt;/callId&gt;&#34; \
                  f&#34;&lt;/conferenceParticipant&gt;&#34; \
                  f&#34;&lt;conferenceParticipant&gt;&#34; \
                  f&#34;&lt;callId&gt;{self._transfer_call.id}&lt;/callId&gt;&#34; \
                  f&#34;&lt;/conferenceParticipant&gt;&#34; \
                  f&#34;&lt;/conferenceParticipantList&gt;&#34; \
                  f&#34;&lt;/Conference&gt;&#34;
            # Building the XML by hand for right now. Probably going to replace it with something JSON-friendly
            headers = self._headers
            headers[&#39;Content-Type&#39;] = &#34;application/xml; charset=UTF-8&#34;
            r = requests.post(self._url + f&#34;/Conference&#34;, headers=headers, data=xml)
            if r.status_code in [200, 201, 204]:
                return self._parent.new_conference([self.id, self._transfer_call.id])
            else:
                return False
        else:
            # Still needs work.
            pass

    def send_dtmf(self, dtmf: str):
        &#34;&#34;&#34;Transmit DTMF tones outbound

        Args:
            dtmf (str): The string of dtmf digits to send. Accepted digits 0-9, star, pound. A comma will pause
                between digits (i.e. &#34;23456#,123&#34;)

        Returns:
            bool: True if the dtmf was sent successfully
        &#34;&#34;&#34;
        params = {&#34;playdtmf&#34;: str(dtmf)}
        r = requests.put(self._url + f&#34;/{self.id}/TransmitDTMF&#34;, headers=self._headers, params=params)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False, r.text

    def hold(self):
        &#34;&#34;&#34;Place the call on hold

        Returns:
            bool: Whether the hold command was successful

        &#34;&#34;&#34;
        r = requests.put(self._url + f&#34;/{self.id}/Hold&#34;, headers=self._headers)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False

    def resume(self):
        &#34;&#34;&#34;Resume a call that was placed on hold

        Returns:
            bool: Whether the command was successful

        &#34;&#34;&#34;
        r = requests.put(self._url + f&#34;/{self.id}/Talk&#34;, headers=self._headers)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.Call.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Call ID for this call</p></div>
</dd>
<dt id="wxcadm.Call.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"><p>The status of the call</p>
<h2 id="returns">Returns</h2>
<p>dict:</p>
<pre><code>{
'network_call_id' (str): The unique identifier for the Network side of the call
'personality'(str): The user's personalty (Originator or Terminator)
'state' (str): The state of the call
'remote_party' (dict): {
    'address' (str): The address of the remote party
    'call_type' (str): The call type
    }
'endpoint' (dict): {
    'type' (str): The type of endpoint in use
    'AoR' (str): The Address of Record for the endpoint
    }
'appearance' (str): The Call Appearance number
'start_time' (str): The UNIX timestanp of the start of the call
'answer_time' (str): The UNIX timestamp when the call was answered
'status_time' (str): The UNIX timestamp of the status response
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self):
    &#34;&#34;&#34;The status of the call

    Returns:
        dict:

            {
            &#39;network_call_id&#39; (str): The unique identifier for the Network side of the call
            &#39;personality&#39;(str): The user&#39;s personalty (Originator or Terminator)
            &#39;state&#39; (str): The state of the call
            &#39;remote_party&#39; (dict): {
                &#39;address&#39; (str): The address of the remote party
                &#39;call_type&#39; (str): The call type
                }
            &#39;endpoint&#39; (dict): {
                &#39;type&#39; (str): The type of endpoint in use
                &#39;AoR&#39; (str): The Address of Record for the endpoint
                }
            &#39;appearance&#39; (str): The Call Appearance number
            &#39;start_time&#39; (str): The UNIX timestanp of the start of the call
            &#39;answer_time&#39; (str): The UNIX timestamp when the call was answered
            &#39;status_time&#39; (str): The UNIX timestamp of the status response
            }

    &#34;&#34;&#34;
    logging.info(f&#34;Getting call status&#34;)
    r = requests.get(self._url + f&#34;/{self.id}&#34;,
                     headers=self._headers)
    response = r.json()
    logging.debug(f&#34;Call Status response: {response}&#34;)
    if r.status_code == 200:
        return_data = {
            &#34;network_call_id&#34;: response[&#39;Call&#39;][&#39;networkCallId&#39;][&#39;$&#39;],
            &#34;personality&#34;: response[&#39;Call&#39;][&#39;personality&#39;][&#39;$&#39;],
            &#34;state&#34;: response[&#39;Call&#39;][&#39;state&#39;][&#39;$&#39;],
            &#34;remote_party&#34;: {
                &#34;address&#34;: response[&#39;Call&#39;][&#39;remoteParty&#39;][&#39;address&#39;][&#39;$&#39;],
                &#34;call_type&#34;: response[&#39;Call&#39;][&#39;remoteParty&#39;][&#39;callType&#39;][&#39;$&#39;],
            },
            &#34;endpoint&#34;: {
                &#34;type&#34;: response[&#39;Call&#39;][&#39;endpoint&#39;][&#39;@xsi1:type&#39;],
                &#34;AoR&#34;: response[&#39;Call&#39;][&#39;endpoint&#39;][&#39;addressOfRecord&#39;][&#39;$&#39;]
            },
            &#34;appearance&#34;: response[&#39;Call&#39;][&#39;appearance&#39;][&#39;$&#39;],
            &#34;diversion_inhibited&#34;: response[&#39;Call&#39;][&#39;diversionInhibited&#39;],
            &#34;start_time&#34;: response[&#39;Call&#39;][&#39;startTime&#39;][&#39;$&#39;],
            &#34;answer_time&#34;: response[&#39;Call&#39;][&#39;answerTime&#39;][&#39;$&#39;],
            &#34;status_time&#34;: int(time.time())
        }
        return return_data
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.Call.conference"><code class="name flex">
<span>def <span class="ident">conference</span></span>(<span>self, address:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a multi-party conference. If the call is already held and an attended transfer is in progress,
meaning the user is already talking to the transfer-to user, this method will bridge the calls.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The address (usually a phone number or extension) to conference to. Not needed
when the call is already part of an Attended Transfer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the conference is successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conference(self, address: str = &#34;&#34;):
    &#34;&#34;&#34;
    Starts a multi-party conference. If the call is already held and an attended transfer is in progress,
    meaning the user is already talking to the transfer-to user, this method will bridge the calls.

    Args:
        address (str, optional): The address (usually a phone number or extension) to conference to. Not needed
            when the call is already part of an Attended Transfer

    Returns:
        bool: True if the conference is successful

    &#34;&#34;&#34;
    # First, check to see if the call is already part of an attended transfer. If so, just build the conference
    # based on the two call IDs
    if self._transfer_call:
        xml = f&#34;&lt;?xml version=\&#34;1.0\&#34; encoding=\&#34;UTF-8\&#34;?&gt;&#34; \
              f&#34;&lt;Conference xmlns=\&#34;http://schema.broadsoft.com/xsi\&#34;&gt;&#34; \
              f&#34;&lt;conferenceParticipantList&gt;&#34; \
              f&#34;&lt;conferenceParticipant&gt;&#34; \
              f&#34;&lt;callId&gt;{self.id}&lt;/callId&gt;&#34; \
              f&#34;&lt;/conferenceParticipant&gt;&#34; \
              f&#34;&lt;conferenceParticipant&gt;&#34; \
              f&#34;&lt;callId&gt;{self._transfer_call.id}&lt;/callId&gt;&#34; \
              f&#34;&lt;/conferenceParticipant&gt;&#34; \
              f&#34;&lt;/conferenceParticipantList&gt;&#34; \
              f&#34;&lt;/Conference&gt;&#34;
        # Building the XML by hand for right now. Probably going to replace it with something JSON-friendly
        headers = self._headers
        headers[&#39;Content-Type&#39;] = &#34;application/xml; charset=UTF-8&#34;
        r = requests.post(self._url + f&#34;/Conference&#34;, headers=headers, data=xml)
        if r.status_code in [200, 201, 204]:
            return self._parent.new_conference([self.id, self._transfer_call.id])
        else:
            return False
    else:
        # Still needs work.
        pass</code></pre>
</details>
</dd>
<dt id="wxcadm.Call.finish_transfer"><code class="name flex">
<span>def <span class="ident">finish_transfer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Complete an Attended Transfer. This method will only complete if a <code>transfer(address, type="attended")</code>
has been done first.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether or not the transfer completes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish_transfer(self):
    &#34;&#34;&#34;
    Complete an Attended Transfer. This method will only complete if a `transfer(address, type=&#34;attended&#34;)`
    has been done first.

    Returns:
        bool: Whether or not the transfer completes

    &#34;&#34;&#34;
    logging.info(&#34;Completing transfer...&#34;)
    r = requests.put(self._url + f&#34;/{self.id}/ConsultTransfer/{self._transfer_call.id}&#34;, headers=self._headers)
    if r.status_code in [200, 201, 204]:
        return True
    else:
        return False, r.text</code></pre>
</details>
</dd>
<dt id="wxcadm.Call.hangup"><code class="name flex">
<span>def <span class="ident">hangup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hang up the call</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the command was successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hangup(self):
    &#34;&#34;&#34;
    Hang up the call
    Returns:
        bool: Whether the command was successful
    &#34;&#34;&#34;
    logging.info(f&#34;Hanging up call ID: {self.id}&#34;)
    r = requests.delete(self._url + f&#34;/{self.id}&#34;,
                        headers=self._headers)
    if r.status_code == 200:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="wxcadm.Call.hold"><code class="name flex">
<span>def <span class="ident">hold</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Place the call on hold</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the hold command was successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hold(self):
    &#34;&#34;&#34;Place the call on hold

    Returns:
        bool: Whether the hold command was successful

    &#34;&#34;&#34;
    r = requests.put(self._url + f&#34;/{self.id}/Hold&#34;, headers=self._headers)
    if r.status_code in [200, 201, 204]:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="wxcadm.Call.originate"><code class="name flex">
<span>def <span class="ident">originate</span></span>(<span>self, address:str, comment:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>Originate a call on behalf of the Person</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>The address (usually a phone number) to originate the call to</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text comment to attach to the call</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the command was successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def originate(self, address: str, comment: str = &#34;&#34;):
    &#34;&#34;&#34;
    Originate a call on behalf of the Person
    Args:
        address (str): The address (usually a phone number) to originate the call to
        comment (str, optional): Text comment to attach to the call
    Returns:
        bool: Whether the command was successful
    &#34;&#34;&#34;
    logging.info(f&#34;Originating a call to {address} for {self._userid}&#34;)
    params = {&#34;address&#34;: address, &#34;info&#34;: comment}
    r = requests.post(self._url + &#34;/new&#34;, headers=self._headers, params=params)
    response = r.json()
    self.id = response[&#39;CallStartInfo&#39;][&#39;callId&#39;][&#39;$&#39;]
    self._external_tracking_id = response[&#39;CallStartInfo&#39;][&#39;externalTrackingId&#39;][&#39;$&#39;]
    if r.status_code == 201:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="wxcadm.Call.resume"><code class="name flex">
<span>def <span class="ident">resume</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resume a call that was placed on hold</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the command was successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resume(self):
    &#34;&#34;&#34;Resume a call that was placed on hold

    Returns:
        bool: Whether the command was successful

    &#34;&#34;&#34;
    r = requests.put(self._url + f&#34;/{self.id}/Talk&#34;, headers=self._headers)
    if r.status_code in [200, 201, 204]:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="wxcadm.Call.send_dtmf"><code class="name flex">
<span>def <span class="ident">send_dtmf</span></span>(<span>self, dtmf:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Transmit DTMF tones outbound</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dtmf</code></strong> :&ensp;<code>str</code></dt>
<dd>The string of dtmf digits to send. Accepted digits 0-9, star, pound. A comma will pause
between digits (i.e. "23456#,123")</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the dtmf was sent successfully</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_dtmf(self, dtmf: str):
    &#34;&#34;&#34;Transmit DTMF tones outbound

    Args:
        dtmf (str): The string of dtmf digits to send. Accepted digits 0-9, star, pound. A comma will pause
            between digits (i.e. &#34;23456#,123&#34;)

    Returns:
        bool: True if the dtmf was sent successfully
    &#34;&#34;&#34;
    params = {&#34;playdtmf&#34;: str(dtmf)}
    r = requests.put(self._url + f&#34;/{self.id}/TransmitDTMF&#34;, headers=self._headers, params=params)
    if r.status_code in [200, 201, 204]:
        return True
    else:
        return False, r.text</code></pre>
</details>
</dd>
<dt id="wxcadm.Call.transfer"><code class="name flex">
<span>def <span class="ident">transfer</span></span>(<span>self, address:str, type:str='blind')</span>
</code></dt>
<dd>
<div class="desc"><p>Transfer the call to the selected address.</p>
<p>Type of transfer can be controlled with <code>type</code> param. VM transfers will transfer the call directly to the voice
mail of the address, even if the address is the user's own address. Attended transfers require a subsequent call
to <code>finish_transfer()</code> when the actual transfer should happen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>The address (usually a phone number or extension) to transfer the call to</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>['blind','vm','attended']:
The type of transfer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if successful. False if unsuccessful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer(self, address: str, type: str = &#34;blind&#34;):
    &#34;&#34;&#34;Transfer the call to the selected address.

    Type of transfer can be controlled with `type` param. VM transfers will transfer the call directly to the voice
    mail of the address, even if the address is the user&#39;s own address. Attended transfers require a subsequent call
    to `finish_transfer()` when the actual transfer should happen.

    Args:
        address (str): The address (usually a phone number or extension) to transfer the call to
        type (str): [&#39;blind&#39;,&#39;vm&#39;,&#39;attended&#39;]:
            The type of transfer.

    Returns:
        bool: True if successful. False if unsuccessful

    &#34;&#34;&#34;
    logging.info(f&#34;Transferring call {self.id} to {address} for {self._userid}&#34;)
    # Set the address param to be passed to XSI
    params = {&#34;address&#34;: address}
    # Handle an attended transfer first. Anything else is assumed to be blind
    if type.lower() == &#34;attended&#34;:
        # Attended transfer requires the first call to be put on hold and the second call to be
        # placed, so those are here. A separate call to finish_transfer will be required when the transfer should
        # happen.
        self.hold()
        self._transfer_call = self._parent.new_call()
        self._transfer_call.originate(address)
        return True
    elif type.lower() == &#34;vm&#34;:
        r = requests.put(self._url + f&#34;/{self.id}/VmTransfer&#34;, headers=self._headers, params=params)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False
    else:
        r = requests.put(self._url + f&#34;/{self.id}/BlindTransfer&#34;, headers=self._headers, params=params)
        if r.status_code in [200, 201, 204]:
            return True
        else:
            return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.CallQueue"><code class="flex name class">
<span>class <span class="ident">CallQueue</span></span>
<span>(</span><span>parent, id, name, location, phone_number, extension, enabled, get_config=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CallQueue:
    def __init__(self, parent, id, name, location, phone_number, extension, enabled, get_config=True):
        self._parent: Org = parent
        &#34;&#34;&#34;The parent org of this Call Queue&#34;&#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Call Queue&#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;The name of the Call Queue&#34;&#34;&#34;
        self.location_id: str = location
        &#34;&#34;&#34;The Webex ID of the Location associated with this Call Queue&#34;&#34;&#34;
        self.phone_number: str = phone_number
        &#34;&#34;&#34;The DID of the Call Queue&#34;&#34;&#34;
        self.extension: str = extension
        &#34;&#34;&#34;The extension of the Call Queue&#34;&#34;&#34;
        self.enabled: bool = enabled
        &#34;&#34;&#34;True if the Call Queue is enabled. False if disabled&#34;&#34;&#34;
        self.call_forwarding: dict = {}
        &#34;&#34;&#34;The Call Forwarding config for the Call Queue&#34;&#34;&#34;
        self.config: dict = {}
        &#34;&#34;&#34;The configuration dictionary for the Call Queue&#34;&#34;&#34;

        if get_config:
            self.get_queue_config()
            self.get_queue_forwarding()

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    def get_queue_config(self):
        &#34;&#34;&#34;
        Get the configuration of this Call Queue instance
        Returns:
            CallQueue.config: The config dictionary of this Call Queue
        &#34;&#34;&#34;
        r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id + &#34;/queues/&#34; + self.id,
                         headers=self._parent._headers)
        response = r.json()
        self.config = response
        return self.config

    def get_queue_forwarding(self):
        &#34;&#34;&#34;
        Get the Call Forwarding settings for this Call Queue instance

        Returns:
            CallQueue.call_forwarding: The Call Forwarding settings for the Person
        &#34;&#34;&#34;
        # TODO: The rules within Call Forwarding are weird. The rules come back in this call, but they are
        #       different than the /selectiveRules response. It makes sense to aggregate them, but that probably
        #       requires the object-&gt;JSON mapping that we need to do for all classes
        r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id +
                         &#34;/queues/&#34; + self.id + &#34;/callForwarding&#34;,
                         headers=self._parent._headers)
        response = r.json()
        self.call_forwarding = response
        return self.call_forwarding

    def push(self):
        &#34;&#34;&#34;
        Push the contents of the CallQueue.config back to Webex
        Returns:
            CallQueue.config: The updated config attribute pulled from Webex after pushing the change
        &#34;&#34;&#34;
        # TODO: Right now this only pushes .config. It should also push .call_forwarding and .forwarding_rules
        logging.info(f&#34;Pushing Call Queue config to Webex for {self.name}&#34;)
        url = _url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id + &#34;/queues/&#34; + self.id
        print(url)
        r = requests.put(url,
                         headers=self._parent._headers, json=self.config)
        response = r.status_code
        self.get_queue_config()
        return self.config</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.CallQueue.call_forwarding"><code class="name">var <span class="ident">call_forwarding</span></code></dt>
<dd>
<div class="desc"><p>The Call Forwarding config for the Call Queue</p></div>
</dd>
<dt id="wxcadm.CallQueue.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p>The configuration dictionary for the Call Queue</p></div>
</dd>
<dt id="wxcadm.CallQueue.enabled"><code class="name">var <span class="ident">enabled</span></code></dt>
<dd>
<div class="desc"><p>True if the Call Queue is enabled. False if disabled</p></div>
</dd>
<dt id="wxcadm.CallQueue.extension"><code class="name">var <span class="ident">extension</span></code></dt>
<dd>
<div class="desc"><p>The extension of the Call Queue</p></div>
</dd>
<dt id="wxcadm.CallQueue.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Call Queue</p></div>
</dd>
<dt id="wxcadm.CallQueue.location_id"><code class="name">var <span class="ident">location_id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Location associated with this Call Queue</p></div>
</dd>
<dt id="wxcadm.CallQueue.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of the Call Queue</p></div>
</dd>
<dt id="wxcadm.CallQueue.phone_number"><code class="name">var <span class="ident">phone_number</span></code></dt>
<dd>
<div class="desc"><p>The DID of the Call Queue</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.CallQueue.get_queue_config"><code class="name flex">
<span>def <span class="ident">get_queue_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the configuration of this Call Queue instance</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.CallQueue.config" href="#wxcadm.CallQueue.config">CallQueue.config</a></code></dt>
<dd>The config dictionary of this Call Queue</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_queue_config(self):
    &#34;&#34;&#34;
    Get the configuration of this Call Queue instance
    Returns:
        CallQueue.config: The config dictionary of this Call Queue
    &#34;&#34;&#34;
    r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id + &#34;/queues/&#34; + self.id,
                     headers=self._parent._headers)
    response = r.json()
    self.config = response
    return self.config</code></pre>
</details>
</dd>
<dt id="wxcadm.CallQueue.get_queue_forwarding"><code class="name flex">
<span>def <span class="ident">get_queue_forwarding</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Call Forwarding settings for this Call Queue instance</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.CallQueue.call_forwarding" href="#wxcadm.CallQueue.call_forwarding">CallQueue.call_forwarding</a></code></dt>
<dd>The Call Forwarding settings for the Person</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_queue_forwarding(self):
    &#34;&#34;&#34;
    Get the Call Forwarding settings for this Call Queue instance

    Returns:
        CallQueue.call_forwarding: The Call Forwarding settings for the Person
    &#34;&#34;&#34;
    # TODO: The rules within Call Forwarding are weird. The rules come back in this call, but they are
    #       different than the /selectiveRules response. It makes sense to aggregate them, but that probably
    #       requires the object-&gt;JSON mapping that we need to do for all classes
    r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id +
                     &#34;/queues/&#34; + self.id + &#34;/callForwarding&#34;,
                     headers=self._parent._headers)
    response = r.json()
    self.call_forwarding = response
    return self.call_forwarding</code></pre>
</details>
</dd>
<dt id="wxcadm.CallQueue.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Push the contents of the CallQueue.config back to Webex</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.CallQueue.config" href="#wxcadm.CallQueue.config">CallQueue.config</a></code></dt>
<dd>The updated config attribute pulled from Webex after pushing the change</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self):
    &#34;&#34;&#34;
    Push the contents of the CallQueue.config back to Webex
    Returns:
        CallQueue.config: The updated config attribute pulled from Webex after pushing the change
    &#34;&#34;&#34;
    # TODO: Right now this only pushes .config. It should also push .call_forwarding and .forwarding_rules
    logging.info(f&#34;Pushing Call Queue config to Webex for {self.name}&#34;)
    url = _url_base + &#34;v1/telephony/config/locations/&#34; + self.location_id + &#34;/queues/&#34; + self.id
    print(url)
    r = requests.put(url,
                     headers=self._parent._headers, json=self.config)
    response = r.status_code
    self.get_queue_config()
    return self.config</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.Conference"><code class="flex name class">
<span>class <span class="ident">Conference</span></span>
<span>(</span><span>parent:object, calls:list, comment:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>The class for Conference Calls started by a Call.conference()</p>
<p>Initialize a Conference instance for an XSI instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="wxcadm.XSI" href="#wxcadm.XSI">XSI</a></code></dt>
<dd>The XSI instance that owns this conference</dd>
<dt><strong><code>calls</code></strong> :&ensp;<code>list</code></dt>
<dd>Call IDs associated with the Conference. Always two Call IDs to start a Conference.
Any additional Call IDs will be added to the conference as it is created.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>An optional text comment for the Conference</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Conference" href="#wxcadm.Conference">Conference</a></code></dt>
<dd>This instance of the Conference class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conference:
    &#34;&#34;&#34;The class for Conference Calls started by a Call.conference()&#34;&#34;&#34;

    def __init__(self, parent: object, calls: list, comment: str = &#34;&#34;):
        &#34;&#34;&#34;Initialize a Conference instance for an XSI instance

        Args:
            parent (XSI): The XSI instance that owns this conference
            calls (list): Call IDs associated with the Conference. Always two Call IDs to start a Conference.
                Any additional Call IDs will be added to the conference as it is created.
            comment (str, optional): An optional text comment for the Conference

        Returns:
            Conference: This instance of the Conference class

        &#34;&#34;&#34;
        self._parent: XSI = parent
        self._calls: list = calls
        self._userid = self._parent.id
        self._headers = self._parent._headers
        self._url = self._parent.xsi_endpoints[&#39;actions_endpoint&#39;] + f&#34;/v2.0/user/{self._userid}/calls/Conference&#34;
        self.comment: str = comment
        &#34;&#34;&#34;Text comment associated with the Conference&#34;&#34;&#34;

    def deaf(self, call: str):
        &#34;&#34;&#34;Stop audio and video from being sent to a participant. Audio and video from that participant are unaffected.

        Args:
            call (str): The Call ID to make deaf

        Returns:
            bool: Whether the command was successful

        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.Conference.comment"><code class="name">var <span class="ident">comment</span></code></dt>
<dd>
<div class="desc"><p>Text comment associated with the Conference</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.Conference.deaf"><code class="name flex">
<span>def <span class="ident">deaf</span></span>(<span>self, call:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop audio and video from being sent to a participant. Audio and video from that participant are unaffected.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>call</code></strong> :&ensp;<code>str</code></dt>
<dd>The Call ID to make deaf</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the command was successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deaf(self, call: str):
    &#34;&#34;&#34;Stop audio and video from being sent to a participant. Audio and video from that participant are unaffected.

    Args:
        call (str): The Call ID to make deaf

    Returns:
        bool: Whether the command was successful

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.HuntGroup"><code class="flex name class">
<span>class <span class="ident">HuntGroup</span></span>
<span>(</span><span>parent:object, id:str, name:str, location:str, enabled:bool, phone_number:str=None, extension:str=None, config:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a HuntGroup instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="wxcadm.Org" href="#wxcadm.Org">Org</a></code></dt>
<dd>The Org instance to which the Hunt Group belongs</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Webex ID for the Hunt Group</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the Hunt Group</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>The Location ID associated with the Hunt Group</dd>
<dt><strong><code>enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Boolean indicating whether the Hunt Group is enabled</dd>
<dt><strong><code>phone_number</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The DID for the Hunt Group</dd>
<dt><strong><code>extension</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension of the Hunt Group</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.HuntGroup" href="#wxcadm.HuntGroup">HuntGroup</a></code></dt>
<dd>The HuntGroup instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HuntGroup:
    def __init__(self, parent: object,
                 id: str,
                 name: str,
                 location: str,
                 enabled: bool,
                 phone_number: str = None,
                 extension: str = None,
                 config: bool = True
                 ):
        &#34;&#34;&#34;
        Initialize a HuntGroup instance
        Args:
            parent (Org): The Org instance to which the Hunt Group belongs
            id (str): The Webex ID for the Hunt Group
            name (str): The name of the Hunt Group
            location (str): The Location ID associated with the Hunt Group
            enabled (bool): Boolean indicating whether the Hunt Group is enabled
            phone_number (str, optional): The DID for the Hunt Group
            extension (str, optional): The extension of the Hunt Group
        Returns:
            HuntGroup: The HuntGroup instance
        &#34;&#34;&#34;

        # Instance attrs
        self.parent: object = parent
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Hunt Group&#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;The name of the Hunt Group&#34;&#34;&#34;
        self.location: str = location
        &#34;&#34;&#34;The Location ID associated with the Hunt Group&#34;&#34;&#34;
        self.enabled: bool = enabled
        &#34;&#34;&#34;Whether the Hunt Group is enabled or not&#34;&#34;&#34;
        self.phone_number: str = phone_number
        &#34;&#34;&#34;The DID for the Hunt Group&#34;&#34;&#34;
        self.extension: str = extension
        &#34;&#34;&#34;The extension of the Hunt Group&#34;&#34;&#34;
        self.agents: list = []
        &#34;&#34;&#34;List of agents/users assigned to this Hunt Group&#34;&#34;&#34;
        self.distinctive_ring: bool = False
        &#34;&#34;&#34;Whether or not the Hunt Group has Distinctive Ring enabled&#34;&#34;&#34;
        self.alternate_numbers_settings: dict = {}
        &#34;&#34;&#34;List of alternate numbers for this Hunt Group&#34;&#34;&#34;
        self.language: str = &#34;&#34;
        &#34;&#34;&#34;The language name for the Hunt Group&#34;&#34;&#34;
        self.language_code: str = &#34;&#34;
        &#34;&#34;&#34;The short name for the language of the Hunt Group&#34;&#34;&#34;
        self.first_name: str = &#34;&#34;
        &#34;&#34;&#34;The Caller ID first name for the Hunt Group&#34;&#34;&#34;
        self.last_name: str = &#34;&#34;
        &#34;&#34;&#34;The Caller ID last name for the Hunt Group&#34;&#34;&#34;
        self.time_zone: str = &#34;&#34;
        &#34;&#34;&#34;The time zone for the Hunt Group&#34;&#34;&#34;
        self.call_policy: dict = {}
        &#34;&#34;&#34;The Call Policy for the Hunt Group&#34;&#34;&#34;
        self.agents: list = []
        &#34;&#34;&#34;List of users assigned to this Hunt Group&#34;&#34;&#34;
        self.raw_config: dict = {}
        &#34;&#34;&#34;The raw JSON-to-Python config from Webex&#34;&#34;&#34;

        # Get the config unless we are asked not to
        if config:
            logging.info(f&#34;Getting config for Hunt Group {self.id} in Location {self.location}&#34;)
            self.get_config()

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    def get_config(self):
        &#34;&#34;&#34;Get the Hunt Group config, including agents&#34;&#34;&#34;
        r = requests.get(_url_base + f&#34;v1/telephony/config/locations/{self.location}/huntGroups/{self.id}&#34;,
                         headers=self.parent._headers)
        response = r.json()
        self.raw_config = response
        self.agents = response[&#39;agents&#39;]
        self.distinctive_ring = response.get(&#34;distinctiveRing&#34;, False)
        self.alternate_numbers_settings = response[&#39;alternateNumberSettings&#39;]
        self.language = response[&#39;language&#39;]
        self.language_code = response[&#39;languageCode&#39;]
        self.first_name = response[&#39;firstName&#39;]
        self.last_name = response[&#39;lastName&#39;]
        self.time_zone = response[&#39;timeZone&#39;]
        self.call_policy = response[&#39;callPolicies&#39;]

        return self.raw_config</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.HuntGroup.agents"><code class="name">var <span class="ident">agents</span></code></dt>
<dd>
<div class="desc"><p>List of users assigned to this Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.alternate_numbers_settings"><code class="name">var <span class="ident">alternate_numbers_settings</span></code></dt>
<dd>
<div class="desc"><p>List of alternate numbers for this Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.call_policy"><code class="name">var <span class="ident">call_policy</span></code></dt>
<dd>
<div class="desc"><p>The Call Policy for the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.distinctive_ring"><code class="name">var <span class="ident">distinctive_ring</span></code></dt>
<dd>
<div class="desc"><p>Whether or not the Hunt Group has Distinctive Ring enabled</p></div>
</dd>
<dt id="wxcadm.HuntGroup.enabled"><code class="name">var <span class="ident">enabled</span></code></dt>
<dd>
<div class="desc"><p>Whether the Hunt Group is enabled or not</p></div>
</dd>
<dt id="wxcadm.HuntGroup.extension"><code class="name">var <span class="ident">extension</span></code></dt>
<dd>
<div class="desc"><p>The extension of the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.first_name"><code class="name">var <span class="ident">first_name</span></code></dt>
<dd>
<div class="desc"><p>The Caller ID first name for the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.language"><code class="name">var <span class="ident">language</span></code></dt>
<dd>
<div class="desc"><p>The language name for the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.language_code"><code class="name">var <span class="ident">language_code</span></code></dt>
<dd>
<div class="desc"><p>The short name for the language of the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.last_name"><code class="name">var <span class="ident">last_name</span></code></dt>
<dd>
<div class="desc"><p>The Caller ID last name for the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.location"><code class="name">var <span class="ident">location</span></code></dt>
<dd>
<div class="desc"><p>The Location ID associated with the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.phone_number"><code class="name">var <span class="ident">phone_number</span></code></dt>
<dd>
<div class="desc"><p>The DID for the Hunt Group</p></div>
</dd>
<dt id="wxcadm.HuntGroup.raw_config"><code class="name">var <span class="ident">raw_config</span></code></dt>
<dd>
<div class="desc"><p>The raw JSON-to-Python config from Webex</p></div>
</dd>
<dt id="wxcadm.HuntGroup.time_zone"><code class="name">var <span class="ident">time_zone</span></code></dt>
<dd>
<div class="desc"><p>The time zone for the Hunt Group</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.HuntGroup.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Hunt Group config, including agents</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    &#34;&#34;&#34;Get the Hunt Group config, including agents&#34;&#34;&#34;
    r = requests.get(_url_base + f&#34;v1/telephony/config/locations/{self.location}/huntGroups/{self.id}&#34;,
                     headers=self.parent._headers)
    response = r.json()
    self.raw_config = response
    self.agents = response[&#39;agents&#39;]
    self.distinctive_ring = response.get(&#34;distinctiveRing&#34;, False)
    self.alternate_numbers_settings = response[&#39;alternateNumberSettings&#39;]
    self.language = response[&#39;language&#39;]
    self.language_code = response[&#39;languageCode&#39;]
    self.first_name = response[&#39;firstName&#39;]
    self.last_name = response[&#39;lastName&#39;]
    self.time_zone = response[&#39;timeZone&#39;]
    self.call_policy = response[&#39;callPolicies&#39;]

    return self.raw_config</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>parent:<a title="wxcadm.Org" href="#wxcadm.Org">Org</a>, location_id:str, name:str, address:dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a Location instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Webex ID of the Location</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the Location</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>dict</code></dt>
<dd>The address information for the Location</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Location (object): The Location instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Location:
    def __init__(self, parent: Org, location_id: str, name: str, address: dict = None):
        &#34;&#34;&#34;Initialize a Location instance

        Args:
            location_id (str): The Webex ID of the Location
            name (str): The name of the Location
            address (dict): The address information for the Location

        Returns:
             Location (object): The Location instance

        &#34;&#34;&#34;
        self._parent = parent
        self.id: str = location_id
        &#34;&#34;&#34;The Webex ID of the Location&#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;The name of the Location&#34;&#34;&#34;
        self.address: dict = address
        &#34;&#34;&#34;The address of the Location&#34;&#34;&#34;

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    @property
    def spark_id(self):
        &#34;&#34;&#34;The ID used by all of the underlying services.&#34;&#34;&#34;
        bytes = base64.b64decode(self.id + &#34;===&#34;)
        spark_id = bytes.decode(&#34;utf-8&#34;)
        return spark_id

    @property
    def hunt_groups(self):
        &#34;&#34;&#34;List of HuntGroup instances for this Location&#34;&#34;&#34;
        my_hunt_groups = []
        for hg in self._parent.hunt_groups:
            if hg.location == self.id:
                my_hunt_groups.append(hg)
        return my_hunt_groups

    @property
    def call_queues(self):
        &#34;&#34;&#34;List of CallQueue instances for this Location&#34;&#34;&#34;
        my_call_queues = []
        for cq in self._parent.call_queues:
            if cq.location_id == self.id:
                my_call_queues.append(cq)
        return my_call_queues

    @property
    def available_numbers(self):
        &#34;&#34;&#34;Returns all of the available numbers for the Location.

        Only returns active numbers, so numbers that have not been activated yet will not be returned.

        Returns:
            list[dict]: A list of available numbers, in dict form

        &#34;&#34;&#34;
        available_numbers = []
        for number in self._parent.numbers:
            if number[&#39;location&#39;].name == self.name and number.get(&#39;state&#39;, &#34;&#34;) == &#34;ACTIVE&#34;:
                available_numbers.append(number)
        return available_numbers</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.Location.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<div class="desc"><p>The address of the Location</p></div>
</dd>
<dt id="wxcadm.Location.available_numbers"><code class="name">var <span class="ident">available_numbers</span></code></dt>
<dd>
<div class="desc"><p>Returns all of the available numbers for the Location.</p>
<p>Only returns active numbers, so numbers that have not been activated yet will not be returned.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict]</code></dt>
<dd>A list of available numbers, in dict form</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def available_numbers(self):
    &#34;&#34;&#34;Returns all of the available numbers for the Location.

    Only returns active numbers, so numbers that have not been activated yet will not be returned.

    Returns:
        list[dict]: A list of available numbers, in dict form

    &#34;&#34;&#34;
    available_numbers = []
    for number in self._parent.numbers:
        if number[&#39;location&#39;].name == self.name and number.get(&#39;state&#39;, &#34;&#34;) == &#34;ACTIVE&#34;:
            available_numbers.append(number)
    return available_numbers</code></pre>
</details>
</dd>
<dt id="wxcadm.Location.call_queues"><code class="name">var <span class="ident">call_queues</span></code></dt>
<dd>
<div class="desc"><p>List of CallQueue instances for this Location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_queues(self):
    &#34;&#34;&#34;List of CallQueue instances for this Location&#34;&#34;&#34;
    my_call_queues = []
    for cq in self._parent.call_queues:
        if cq.location_id == self.id:
            my_call_queues.append(cq)
    return my_call_queues</code></pre>
</details>
</dd>
<dt id="wxcadm.Location.hunt_groups"><code class="name">var <span class="ident">hunt_groups</span></code></dt>
<dd>
<div class="desc"><p>List of HuntGroup instances for this Location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hunt_groups(self):
    &#34;&#34;&#34;List of HuntGroup instances for this Location&#34;&#34;&#34;
    my_hunt_groups = []
    for hg in self._parent.hunt_groups:
        if hg.location == self.id:
            my_hunt_groups.append(hg)
    return my_hunt_groups</code></pre>
</details>
</dd>
<dt id="wxcadm.Location.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Location</p></div>
</dd>
<dt id="wxcadm.Location.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of the Location</p></div>
</dd>
<dt id="wxcadm.Location.spark_id"><code class="name">var <span class="ident">spark_id</span></code></dt>
<dd>
<div class="desc"><p>The ID used by all of the underlying services.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spark_id(self):
    &#34;&#34;&#34;The ID used by all of the underlying services.&#34;&#34;&#34;
    bytes = base64.b64decode(self.id + &#34;===&#34;)
    spark_id = bytes.decode(&#34;utf-8&#34;)
    return spark_id</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.Org"><code class="flex name class">
<span>class <span class="ident">Org</span></span>
<span>(</span><span>name:str, id:str, parent:<a title="wxcadm.Webex" href="#wxcadm.Webex">Webex</a>=None, people:bool=True, locations:bool=True, hunt_groups:bool=False, call_queues:bool=False, xsi:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for working with wxcadm.</p>
<p>Initialize an Org instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The Organization name</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Webex ID of the Organization</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="wxcadm.Webex" href="#wxcadm.Webex">Webex</a></code>, optional</dt>
<dd>The parent Webex instance that owns this Org.</dd>
<dt><strong><code>people</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get all People for the Org. Default True.</dd>
<dt><strong><code>locations</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get all Locations for the Org. Default True.</dd>
<dt><strong><code>hunt_groups</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get all Hunt Groups for the Org. Default False.</dd>
<dt><strong><code>call_queues</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get all Call Queues for the Org. Default False.</dd>
<dt><strong><code>xsi</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get the XSI Endpoints for the Org. Default False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Org" href="#wxcadm.Org">Org</a></code></dt>
<dd>This instance of the Org class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Org(Webex):
    def __init__(self,
                 name: str,
                 id: str,
                 parent: Webex = None,
                 people: bool = True,
                 locations: bool = True,
                 hunt_groups: bool = False,
                 call_queues: bool = False,
                 xsi: bool = False,
                 ):
        &#34;&#34;&#34;Initialize an Org instance

        Args:
            name (str): The Organization name
            id (str): The Webex ID of the Organization
            parent (Webex, optional): The parent Webex instance that owns this Org.
            people (bool, optional): Whether to get all People for the Org. Default True.
            locations (bool, optional): Whether to get all Locations for the Org. Default True.
            hunt_groups (bool, optional): Whether to get all Hunt Groups for the Org. Default False.
            call_queues (bool, optional): Whether to get all Call Queues for the Org. Default False.
            xsi (bool, optional): Whether to get the XSI Endpoints for the Org. Default False.

        Returns:
            Org: This instance of the Org class

        &#34;&#34;&#34;

        # Instance attrs
        self._parent = parent
        self.call_queues: list[CallQueue] = None
        &#34;&#34;&#34;The Call Queues for this Org&#34;&#34;&#34;
        self.hunt_groups: list[HuntGroup] = None
        &#34;&#34;&#34;The Hunt Groups for this Org&#34;&#34;&#34;
        self.pickup_groups: list[PickupGroup] = None
        &#39;A list of the PickupGroup instances for this Org&#39;
        self.locations: list[Location] = []
        &#39;A list of the Location instances for this Org&#39;
        self.name: str = name
        &#39;The name of the Organization&#39;
        self.id: str = id
        &#39;&#39;&#39;The Webex ID of the Organization&#39;&#39;&#39;
        self.xsi: dict = {}
        &#34;&#34;&#34;The XSI details for the Organization&#34;&#34;&#34;
        self._params: dict = {&#34;orgId&#34;: self.id}
        self.licenses: list[dict] = []
        &#39;&#39;&#39;A list of all of the licenses for the Organization as a dictionary of names and IDs&#39;&#39;&#39;
        self.people: list[Person] = []
        &#39;&#39;&#39;A list of all of the Person stances for the Organization&#39;&#39;&#39;
        self.workspaces: list[Workspace] = None
        &#34;&#34;&#34;A list of the Workspace instances for this Org.&#34;&#34;&#34;
        self.workspace_locations: list[WorkspaceLocation] = None
        &#34;&#34;&#34;A list of the Workspace Location instanced for this Org.&#34;&#34;&#34;

        # Set the Authorization header based on how the instance was built
        self._headers = parent.headers
        self.licenses = self.__get_licenses()

        # Create a CPAPI instance for CPAPI work
        self._cpapi = CPAPI(self, self._parent._access_token)

        # Get all of the people if we aren&#39;t told not to
        if people:
            self.get_people()
        if locations:
            self.get_locations()
        if xsi:
            self.get_xsi_endpoints()
        if call_queues:
            self.get_call_queues()
        if hunt_groups:
            self.get_hunt_groups()

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    def __get_licenses(self):
        &#34;&#34;&#34;Gets all of the licenses for the Organization

        Returns:
            list: List of dictionaries containing the license name and ID

        &#34;&#34;&#34;
        logging.info(&#34;__get_licenses() started for org&#34;)
        license_list = []
        r = requests.get(_url_base + &#34;v1/licenses&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for item in response[&#39;items&#39;]:
            if &#34;Webex Calling&#34; in item[&#39;name&#39;]:
                wxc_license = True
                if &#34;Professional&#34; in item[&#39;name&#39;]:
                    wxc_type = &#34;person&#34;
                elif &#34;Workspace&#34; in item[&#39;name&#39;]:
                    wxc_type = &#34;workspace&#34;
                else:
                    wxc_type = &#34;unknown&#34;
            else:
                wxc_license = False
                wxc_type = None
            lic = {&#34;name&#34;: item[&#39;name&#39;],
                   &#34;id&#34;: item[&#39;id&#39;],
                   &#34;total&#34;: item[&#39;totalUnits&#39;],
                   &#34;consumed&#34;: item[&#39;consumedUnits&#39;],
                   &#34;subscription&#34;: item.get(&#34;subscriptionId&#34;, &#34;&#34;),
                   &#34;wxc_license&#34;: wxc_license,
                   &#34;wxc_type&#34;: wxc_type
                   }
            license_list.append(lic)
        return license_list

    @property
    def numbers(self):
        &#34;&#34;&#34;All of the Numbers for the Org

        Returns:
            list[dict]: List of dict containing information about each number

        &#34;&#34;&#34;
        my_numbers = self._cpapi.get_numbers()
        for num in my_numbers:
            if &#34;owner&#34; in num:
                person = self.get_person_by_id(num[&#39;owner&#39;][&#39;id&#39;])
                if person is not None:
                    num[&#39;owner&#39;] = person
            if &#34;location&#34; in num:
                location = self.get_location_by_name(num[&#39;location&#39;][&#39;name&#39;])
                if location is not None:
                    num[&#39;location&#39;] = location
        return my_numbers

    def get_location_by_name(self, name: str):
        &#34;&#34;&#34;Get the Location instance associated with a given Location ID

        Args:
            name (str): The full name of the Location to look for. (Case sensitive)

        Returns:
            Location: The Location instance. If no match is found, None is returned

        &#34;&#34;&#34;
        for location in self.locations:
            if location.name == name:
                return location
        return None

    def get_person_by_id(self, id: str):
        &#34;&#34;&#34;Get the Person instance associated with a given ID

        Args:
            id (str): The Webex ID of the Person to look for.

        Returns:
            Person: The Person instance. If no match is found, None is returned

        &#34;&#34;&#34;
        for person in self.people:
            if person.id == id:
                return person
        return None


    def __get_wxc_licenses(self):
        &#34;&#34;&#34;Get only the Webex Calling licenses from the Org.licenses attribute

        Returns:
            list[str]:

        &#34;&#34;&#34;
        logging.info(&#34;__get_wxc_licenses started&#34;)
        license_list = []
        for license in self.licenses:
            if license[&#39;wxc_license&#39;]:
                license_list.append(license[&#39;id&#39;])
        return license_list

    def get_wxc_person_license(self):
        &#34;&#34;&#34;Get the Webex Calling - Professional license ID

        Returns:
            str: The License ID

        &#34;&#34;&#34;
        logging.info(&#34;__get_wxc_person_license started to find available license&#34;)
        for license in self.licenses:
            if license[&#39;wxc_type&#39;] == &#34;person&#34;:
                return license[&#39;id&#39;]
        raise LicenseError(&#34;No Webex Calling Professional license found&#34;)

    def create_person(self, email: str,
                      location: str,
                      licenses: list = None,
                      calling: bool = True,
                      messaging: bool = True,
                      meetings: bool = True,
                      phone_number: str = None,
                      extension: str = None,
                      first_name: str = None,
                      last_name: str = None,
                      display_name: str = None,
                      ):
        &#34;&#34;&#34;Create a new user in Webex.

        Also creates a new Person instance for the created user.

        Args:
            email (str): The email address of the user
            location (str): The ID of the Location that the user is assigned to.
            licenses (list, optional): List of license IDs to assign to the user. Use this when the license IDs
            are known. To have the license IDs determined dynamically, use the `calling`, `messaging` and
            meetings` parameters.

            calling (bool, optional): BETA - Whether to assign Calling licenses to the user. Defaults to True.
            messaging (bool, optional): BETA - Whether to assign Messaging licenses to the user. Defaults to True.
            meetings (bool, optional): BETA - Whether to assign Messaging licenses to the user. Defaults to True.
            phone_number (str, optional): The phone number to assign to the user.
            extension (str, optional): The extension to assign to the user
            first_name (str, optional): The user&#39;s first name. Defaults to empty string.
            last_name (str, optional): The users&#39; last name. Defaults to empty string.
            display_name (str, optional): The full name of the user as displayed in Webex. If first name and last name are passed
                without display_name, the display name will be the concatenation of first and last name.

        Returns:
            Person: The Person instance of the newly-created user.

        &#34;&#34;&#34;
        if (first_name or last_name) and not display_name:
            display_name = f&#34;{first_name} {last_name}&#34;

        # Find the license IDs for each requested service, unless licenses was passed
        if not licenses:
            if calling:
                licenses.append(self.get_wxc_person_license())
            if messaging:
                pass
            if meetings:
                pass

        # Build the payload to send to the API
        payload = {&#34;emails&#34;: [email],
                   &#34;phoneNumbers&#34;: [{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: phone_number}],
                   &#34;extension&#34;: extension,
                   &#34;locationId&#34;: location,
                   &#34;displayName&#34;: display_name,
                   &#34;firstName&#34;: first_name,
                   &#34;lastName&#34;: last_name,
                   &#34;orgId&#34;: self.id,
                   &#34;licenses&#34;: licenses
                   }
        r = requests.post(_url_base + &#34;v1/people&#34;, headers=self._headers, params={&#34;callingData&#34;: &#34;true&#34;},
                          json=payload)
        response = r.json()
        if r.status_code == 200:
            person = Person(response[&#39;id&#39;], self, response)
            self.people.append(person)
            return person
        else:
            return f&#34;{r.status_code} - {r.text}&#34;

    def get_person_by_email(self, email):
        &#34;&#34;&#34;Get the Person instance from an email address

        Args:
            email (str): The email of the Person to return

        Returns:
            Person: Person instance object. None in returned when no Person is found

        &#34;&#34;&#34;
        logging.info(&#34;get_person_by_email() started&#34;)
        for person in self.people:
            if person.email == email:
                return person
        return None

    def get_xsi_endpoints(self):
        &#34;&#34;&#34;Get the XSI endpoints for the Organization.

        Also stores them in the Org.xsi attribute.

        Returns:
            dict: Org.xsi attribute dictionary with each endpoint as an entry.

        &#34;&#34;&#34;
        params = {&#34;callingData&#34;: &#34;true&#34;, **self._params}
        r = requests.get(_url_base + &#34;v1/organizations/&#34; + self.id, headers=self._headers, params=params)
        response = r.json()
        if &#34;xsiActionsEndpoint&#34; in response:
            self.xsi[&#39;actions_endpoint&#39;] = response[&#39;xsiActionsEndpoint&#39;]
            self.xsi[&#39;events_endpoint&#39;] = response[&#39;xsiEventsEndpoint&#39;]
            self.xsi[&#39;events_channel_endpoint&#39;] = response[&#39;xsiEventsChannelEndpoint&#39;]
        else:
            raise XSIError(&#34;XSI requested but not present in Org. Contact Cisco TAC to enable XSI.&#34;)
        return self.xsi

    def get_locations(self):
        &#34;&#34;&#34;Get the Locations for the Organization.

        Also stores them in the Org.locations attribute.

        Returns:
            list[Location]: List of Location instance objects. See the Locations class for attributes.

        &#34;&#34;&#34;
        logging.info(&#34;get_locations() started&#34;)
        r = requests.get(_url_base + &#34;v1/locations&#34;, headers=self._headers, params=self._params)
        response = r.json()
        # I am aware that this doesn&#39;t support pagination, so there will be a limit on number of Locations returned
        for location in response[&#39;items&#39;]:
            this_location = Location(self, location[&#39;id&#39;], location[&#39;name&#39;], address=location[&#39;address&#39;])
            self.locations.append(this_location)

        return self.locations

    def get_workspaces(self):
        &#34;&#34;&#34;Get the Workspaces and Workspace Locations for the Organizations.

        Also stores them in the Org.workspaces and Org.workspace_locations attributes.

        Returns:
            list[Workspace]: List of Workspace instance objects. See the Workspace class for attributes.

        &#34;&#34;&#34;
        logging.info(&#34;Getting Workspaces&#34;)
        self.workspaces = []
        r = requests.get(_url_base + &#34;v1/workspaces&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for workspace in response[&#39;items&#39;]:
            this_workspace = Workspace(self, workspace[&#39;id&#39;], workspace)
            self.workspaces.append(this_workspace)

        logging.info(&#34;Getting Workspace Locations&#34;)
        self.workspace_locations = []
        r = requests.get(_url_base + &#34;v1/workspaceLocations&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for location in response[&#39;items&#39;]:
            this_location = WorkspaceLocation(self, location[&#39;id&#39;], location)
            self.workspace_locations.append(this_location)

        return self.workspaces

    def get_pickup_groups(self):
        &#34;&#34;&#34;Get all of the Call Pickup Groups for an Organization.

        Also stores them in the Org.pickup_groups attribute.

        Returns:
            list[PickupGroup]: List of Call Pickup Groups as a list of dictionaries.
            See the PickupGroup class for attributes.

        &#34;&#34;&#34;
        logging.info(&#34;get_pickup_groups() started&#34;)
        self.pickup_groups = []
        # First we need to know if we already have locations, because they are needed
        # for the pickup groups call
        if not self.locations:
            self.get_locations()
        # Loop through all of the locations and get their pickup groups
        # We will create a new instance of the PickupGroup class when we find one
        for location in self.locations:
            r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + location.id + &#34;/callPickups&#34;,
                             headers=self._headers)
            response = r.json()
            for item in response[&#39;callPickups&#39;]:
                pg = PickupGroup(self, location.id, item[&#39;id&#39;], item[&#39;name&#39;])
                self.pickup_groups.append(pg)
        return self.pickup_groups

    def get_call_queues(self):
        &#34;&#34;&#34;Get the Call Queues for an Organization.

        Also stores them in the Org.call_queues attribute.

        Returns:
            list[CallQueue]: List of CallQueue instances for the Organization

        &#34;&#34;&#34;
        logging.info(&#34;get_call_queues() started&#34;)
        self.call_queues = []
        if not self.locations:
            self.get_locations()
        r = requests.get(_url_base + &#34;v1/telephony/config/queues&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for queue in response[&#39;queues&#39;]:
            id = queue.get(&#34;id&#34;)
            name = queue.get(&#34;name&#34;, None)
            location_id = queue.get(&#34;locationId&#34;)
            phone_number = queue.get(&#34;phoneNumber&#34;, None)
            extension = queue.get(&#34;extension&#34;, None)
            enabled = queue.get(&#34;enabled&#34;)

            queue = CallQueue(self, id, name, location_id, phone_number, extension, enabled, get_config=True)
            self.call_queues.append(queue)
        return self.call_queues

    def get_hunt_groups(self):
        &#34;&#34;&#34;Get the Hunt Groups for an Organization.

        Also stores them in the Org.hunt_groups attribute.

        Returns:
            list[HuntGroup]: List of HuntGroup instances for the Organization

        &#34;&#34;&#34;
        logging.info(&#34;get_hunt_groups() started&#34;)
        self.hunt_groups = []
        if not self.locations:
            self.get_locations()
        r = requests.get(_url_base + &#34;v1/telephony/config/huntGroups&#34;, headers=self._headers, params=self._params)
        response = r.json()
        for hg in response[&#39;huntGroups&#39;]:
            hunt_group = HuntGroup(self, hg[&#39;id&#39;], hg[&#39;name&#39;], hg[&#39;locationId&#39;], hg[&#39;enabled&#39;],
                                   hg.get(&#34;phoneNumber&#34;, &#34;&#34;), hg.get(&#34;extension&#34;, &#34;&#34;))
            self.hunt_groups.append(hunt_group)
        return self.hunt_groups

    def get_people(self):
        &#34;&#34;&#34;Get all of the people within the Organization.

        Also creates a Person instance and stores it in the Org.people attributes

        Returns:
            list[Person]: List of Person instances

        &#34;&#34;&#34;
        logging.info(&#34;get_people() started&#34;)
        params = {&#34;max&#34;: &#34;1000&#34;, &#34;callingData&#34;: &#34;true&#34;, **self._params}
        r = requests.get(_url_base + &#34;v1/people&#34;, headers=self._headers, params=params)
        people_list = r.json()

        if &#34;next&#34; in r.links:
            keep_going = True
            next_url = r.links[&#39;next&#39;][&#39;url&#39;]
            while keep_going:
                r = requests.get(next_url, headers=self._headers)
                new_people = r.json()
                if &#34;items&#34; not in new_people:
                    continue
                people_list[&#39;items&#39;].extend(new_people[&#39;items&#39;])
                if &#34;next&#34; not in r.links:
                    keep_going = False
                else:
                    next_url = r.links[&#39;next&#39;][&#39;url&#39;]

        self.wxc_licenses = self.__get_wxc_licenses()
        for person in people_list[&#39;items&#39;]:
            this_person = Person(person[&#39;id&#39;], parent=self, config=person)
            self.people.append(this_person)
        return self.people

    def get_wxc_people(self):
        &#34;&#34;&#34;Get all of the people within the Organization **who have Webex Calling**

        Returns:
            list[Person]: List of Person instances of people who have a Webex Calling license

        &#34;&#34;&#34;
        if not self.people:
            self.get_people()
        wxc_people = []
        for person in self.people:
            if person.wxc:
                wxc_people.append(person)
        return wxc_people

    def get_license_name(self, license_id: str):
        &#34;&#34;&#34;Gets the name of a license by its ID

        Args:
            license_id (str): The License ID

        Returns:
            str: The License name. None if not found.

        &#34;&#34;&#34;
        for license in self.licenses:
            if license[&#39;id&#39;] == license_id:
                return license[&#39;name&#39;]
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wxcadm.Webex" href="#wxcadm.Webex">Webex</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.Org.call_queues"><code class="name">var <span class="ident">call_queues</span></code></dt>
<dd>
<div class="desc"><p>The Call Queues for this Org</p></div>
</dd>
<dt id="wxcadm.Org.hunt_groups"><code class="name">var <span class="ident">hunt_groups</span></code></dt>
<dd>
<div class="desc"><p>The Hunt Groups for this Org</p></div>
</dd>
<dt id="wxcadm.Org.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Organization</p></div>
</dd>
<dt id="wxcadm.Org.licenses"><code class="name">var <span class="ident">licenses</span></code></dt>
<dd>
<div class="desc"><p>A list of all of the licenses for the Organization as a dictionary of names and IDs</p></div>
</dd>
<dt id="wxcadm.Org.locations"><code class="name">var <span class="ident">locations</span></code></dt>
<dd>
<div class="desc"><p>A list of the Location instances for this Org</p></div>
</dd>
<dt id="wxcadm.Org.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of the Organization</p></div>
</dd>
<dt id="wxcadm.Org.numbers"><code class="name">var <span class="ident">numbers</span></code></dt>
<dd>
<div class="desc"><p>All of the Numbers for the Org</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict]</code></dt>
<dd>List of dict containing information about each number</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def numbers(self):
    &#34;&#34;&#34;All of the Numbers for the Org

    Returns:
        list[dict]: List of dict containing information about each number

    &#34;&#34;&#34;
    my_numbers = self._cpapi.get_numbers()
    for num in my_numbers:
        if &#34;owner&#34; in num:
            person = self.get_person_by_id(num[&#39;owner&#39;][&#39;id&#39;])
            if person is not None:
                num[&#39;owner&#39;] = person
        if &#34;location&#34; in num:
            location = self.get_location_by_name(num[&#39;location&#39;][&#39;name&#39;])
            if location is not None:
                num[&#39;location&#39;] = location
    return my_numbers</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.people"><code class="name">var <span class="ident">people</span></code></dt>
<dd>
<div class="desc"><p>A list of all of the Person stances for the Organization</p></div>
</dd>
<dt id="wxcadm.Org.pickup_groups"><code class="name">var <span class="ident">pickup_groups</span></code></dt>
<dd>
<div class="desc"><p>A list of the PickupGroup instances for this Org</p></div>
</dd>
<dt id="wxcadm.Org.workspace_locations"><code class="name">var <span class="ident">workspace_locations</span></code></dt>
<dd>
<div class="desc"><p>A list of the Workspace Location instanced for this Org.</p></div>
</dd>
<dt id="wxcadm.Org.workspaces"><code class="name">var <span class="ident">workspaces</span></code></dt>
<dd>
<div class="desc"><p>A list of the Workspace instances for this Org.</p></div>
</dd>
<dt id="wxcadm.Org.xsi"><code class="name">var <span class="ident">xsi</span></code></dt>
<dd>
<div class="desc"><p>The XSI details for the Organization</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.Org.create_person"><code class="name flex">
<span>def <span class="ident">create_person</span></span>(<span>self, email:str, location:str, licenses:list=None, calling:bool=True, messaging:bool=True, meetings:bool=True, phone_number:str=None, extension:str=None, first_name:str=None, last_name:str=None, display_name:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new user in Webex.</p>
<p>Also creates a new Person instance for the created user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code></dt>
<dd>The email address of the user</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>The ID of the Location that the user is assigned to.</dd>
<dt><strong><code>licenses</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of license IDs to assign to the user. Use this when the license IDs</dd>
</dl>
<p>are known. To have the license IDs determined dynamically, use the <code>calling</code>, <code>messaging</code> and
meetings` parameters.</p>
<dl>
<dt><strong><code>calling</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>BETA - Whether to assign Calling licenses to the user. Defaults to True.</dd>
<dt><strong><code>messaging</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>BETA - Whether to assign Messaging licenses to the user. Defaults to True.</dd>
<dt><strong><code>meetings</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>BETA - Whether to assign Messaging licenses to the user. Defaults to True.</dd>
<dt><strong><code>phone_number</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The phone number to assign to the user.</dd>
<dt><strong><code>extension</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension to assign to the user</dd>
<dt><strong><code>first_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The user's first name. Defaults to empty string.</dd>
<dt><strong><code>last_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The users' last name. Defaults to empty string.</dd>
<dt><strong><code>display_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The full name of the user as displayed in Webex. If first name and last name are passed
without display_name, the display name will be the concatenation of first and last name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Person" href="#wxcadm.Person">Person</a></code></dt>
<dd>The Person instance of the newly-created user.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_person(self, email: str,
                  location: str,
                  licenses: list = None,
                  calling: bool = True,
                  messaging: bool = True,
                  meetings: bool = True,
                  phone_number: str = None,
                  extension: str = None,
                  first_name: str = None,
                  last_name: str = None,
                  display_name: str = None,
                  ):
    &#34;&#34;&#34;Create a new user in Webex.

    Also creates a new Person instance for the created user.

    Args:
        email (str): The email address of the user
        location (str): The ID of the Location that the user is assigned to.
        licenses (list, optional): List of license IDs to assign to the user. Use this when the license IDs
        are known. To have the license IDs determined dynamically, use the `calling`, `messaging` and
        meetings` parameters.

        calling (bool, optional): BETA - Whether to assign Calling licenses to the user. Defaults to True.
        messaging (bool, optional): BETA - Whether to assign Messaging licenses to the user. Defaults to True.
        meetings (bool, optional): BETA - Whether to assign Messaging licenses to the user. Defaults to True.
        phone_number (str, optional): The phone number to assign to the user.
        extension (str, optional): The extension to assign to the user
        first_name (str, optional): The user&#39;s first name. Defaults to empty string.
        last_name (str, optional): The users&#39; last name. Defaults to empty string.
        display_name (str, optional): The full name of the user as displayed in Webex. If first name and last name are passed
            without display_name, the display name will be the concatenation of first and last name.

    Returns:
        Person: The Person instance of the newly-created user.

    &#34;&#34;&#34;
    if (first_name or last_name) and not display_name:
        display_name = f&#34;{first_name} {last_name}&#34;

    # Find the license IDs for each requested service, unless licenses was passed
    if not licenses:
        if calling:
            licenses.append(self.get_wxc_person_license())
        if messaging:
            pass
        if meetings:
            pass

    # Build the payload to send to the API
    payload = {&#34;emails&#34;: [email],
               &#34;phoneNumbers&#34;: [{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: phone_number}],
               &#34;extension&#34;: extension,
               &#34;locationId&#34;: location,
               &#34;displayName&#34;: display_name,
               &#34;firstName&#34;: first_name,
               &#34;lastName&#34;: last_name,
               &#34;orgId&#34;: self.id,
               &#34;licenses&#34;: licenses
               }
    r = requests.post(_url_base + &#34;v1/people&#34;, headers=self._headers, params={&#34;callingData&#34;: &#34;true&#34;},
                      json=payload)
    response = r.json()
    if r.status_code == 200:
        person = Person(response[&#39;id&#39;], self, response)
        self.people.append(person)
        return person
    else:
        return f&#34;{r.status_code} - {r.text}&#34;</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_call_queues"><code class="name flex">
<span>def <span class="ident">get_call_queues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Call Queues for an Organization.</p>
<p>Also stores them in the Org.call_queues attribute.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.CallQueue" href="#wxcadm.CallQueue">CallQueue</a>]</code></dt>
<dd>List of CallQueue instances for the Organization</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_call_queues(self):
    &#34;&#34;&#34;Get the Call Queues for an Organization.

    Also stores them in the Org.call_queues attribute.

    Returns:
        list[CallQueue]: List of CallQueue instances for the Organization

    &#34;&#34;&#34;
    logging.info(&#34;get_call_queues() started&#34;)
    self.call_queues = []
    if not self.locations:
        self.get_locations()
    r = requests.get(_url_base + &#34;v1/telephony/config/queues&#34;, headers=self._headers, params=self._params)
    response = r.json()
    for queue in response[&#39;queues&#39;]:
        id = queue.get(&#34;id&#34;)
        name = queue.get(&#34;name&#34;, None)
        location_id = queue.get(&#34;locationId&#34;)
        phone_number = queue.get(&#34;phoneNumber&#34;, None)
        extension = queue.get(&#34;extension&#34;, None)
        enabled = queue.get(&#34;enabled&#34;)

        queue = CallQueue(self, id, name, location_id, phone_number, extension, enabled, get_config=True)
        self.call_queues.append(queue)
    return self.call_queues</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_hunt_groups"><code class="name flex">
<span>def <span class="ident">get_hunt_groups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Hunt Groups for an Organization.</p>
<p>Also stores them in the Org.hunt_groups attribute.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.HuntGroup" href="#wxcadm.HuntGroup">HuntGroup</a>]</code></dt>
<dd>List of HuntGroup instances for the Organization</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hunt_groups(self):
    &#34;&#34;&#34;Get the Hunt Groups for an Organization.

    Also stores them in the Org.hunt_groups attribute.

    Returns:
        list[HuntGroup]: List of HuntGroup instances for the Organization

    &#34;&#34;&#34;
    logging.info(&#34;get_hunt_groups() started&#34;)
    self.hunt_groups = []
    if not self.locations:
        self.get_locations()
    r = requests.get(_url_base + &#34;v1/telephony/config/huntGroups&#34;, headers=self._headers, params=self._params)
    response = r.json()
    for hg in response[&#39;huntGroups&#39;]:
        hunt_group = HuntGroup(self, hg[&#39;id&#39;], hg[&#39;name&#39;], hg[&#39;locationId&#39;], hg[&#39;enabled&#39;],
                               hg.get(&#34;phoneNumber&#34;, &#34;&#34;), hg.get(&#34;extension&#34;, &#34;&#34;))
        self.hunt_groups.append(hunt_group)
    return self.hunt_groups</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_license_name"><code class="name flex">
<span>def <span class="ident">get_license_name</span></span>(<span>self, license_id:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the name of a license by its ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>license_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The License ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The License name. None if not found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_license_name(self, license_id: str):
    &#34;&#34;&#34;Gets the name of a license by its ID

    Args:
        license_id (str): The License ID

    Returns:
        str: The License name. None if not found.

    &#34;&#34;&#34;
    for license in self.licenses:
        if license[&#39;id&#39;] == license_id:
            return license[&#39;name&#39;]
    return None</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_location_by_name"><code class="name flex">
<span>def <span class="ident">get_location_by_name</span></span>(<span>self, name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Location instance associated with a given Location ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The full name of the Location to look for. (Case sensitive)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Location" href="#wxcadm.Location">Location</a></code></dt>
<dd>The Location instance. If no match is found, None is returned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_location_by_name(self, name: str):
    &#34;&#34;&#34;Get the Location instance associated with a given Location ID

    Args:
        name (str): The full name of the Location to look for. (Case sensitive)

    Returns:
        Location: The Location instance. If no match is found, None is returned

    &#34;&#34;&#34;
    for location in self.locations:
        if location.name == name:
            return location
    return None</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_locations"><code class="name flex">
<span>def <span class="ident">get_locations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Locations for the Organization.</p>
<p>Also stores them in the Org.locations attribute.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.Location" href="#wxcadm.Location">Location</a>]</code></dt>
<dd>List of Location instance objects. See the Locations class for attributes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_locations(self):
    &#34;&#34;&#34;Get the Locations for the Organization.

    Also stores them in the Org.locations attribute.

    Returns:
        list[Location]: List of Location instance objects. See the Locations class for attributes.

    &#34;&#34;&#34;
    logging.info(&#34;get_locations() started&#34;)
    r = requests.get(_url_base + &#34;v1/locations&#34;, headers=self._headers, params=self._params)
    response = r.json()
    # I am aware that this doesn&#39;t support pagination, so there will be a limit on number of Locations returned
    for location in response[&#39;items&#39;]:
        this_location = Location(self, location[&#39;id&#39;], location[&#39;name&#39;], address=location[&#39;address&#39;])
        self.locations.append(this_location)

    return self.locations</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_people"><code class="name flex">
<span>def <span class="ident">get_people</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all of the people within the Organization.</p>
<p>Also creates a Person instance and stores it in the Org.people attributes</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.Person" href="#wxcadm.Person">Person</a>]</code></dt>
<dd>List of Person instances</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_people(self):
    &#34;&#34;&#34;Get all of the people within the Organization.

    Also creates a Person instance and stores it in the Org.people attributes

    Returns:
        list[Person]: List of Person instances

    &#34;&#34;&#34;
    logging.info(&#34;get_people() started&#34;)
    params = {&#34;max&#34;: &#34;1000&#34;, &#34;callingData&#34;: &#34;true&#34;, **self._params}
    r = requests.get(_url_base + &#34;v1/people&#34;, headers=self._headers, params=params)
    people_list = r.json()

    if &#34;next&#34; in r.links:
        keep_going = True
        next_url = r.links[&#39;next&#39;][&#39;url&#39;]
        while keep_going:
            r = requests.get(next_url, headers=self._headers)
            new_people = r.json()
            if &#34;items&#34; not in new_people:
                continue
            people_list[&#39;items&#39;].extend(new_people[&#39;items&#39;])
            if &#34;next&#34; not in r.links:
                keep_going = False
            else:
                next_url = r.links[&#39;next&#39;][&#39;url&#39;]

    self.wxc_licenses = self.__get_wxc_licenses()
    for person in people_list[&#39;items&#39;]:
        this_person = Person(person[&#39;id&#39;], parent=self, config=person)
        self.people.append(this_person)
    return self.people</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_person_by_email"><code class="name flex">
<span>def <span class="ident">get_person_by_email</span></span>(<span>self, email)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Person instance from an email address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code></dt>
<dd>The email of the Person to return</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Person" href="#wxcadm.Person">Person</a></code></dt>
<dd>Person instance object. None in returned when no Person is found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_person_by_email(self, email):
    &#34;&#34;&#34;Get the Person instance from an email address

    Args:
        email (str): The email of the Person to return

    Returns:
        Person: Person instance object. None in returned when no Person is found

    &#34;&#34;&#34;
    logging.info(&#34;get_person_by_email() started&#34;)
    for person in self.people:
        if person.email == email:
            return person
    return None</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_person_by_id"><code class="name flex">
<span>def <span class="ident">get_person_by_id</span></span>(<span>self, id:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Person instance associated with a given ID</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Webex ID of the Person to look for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Person" href="#wxcadm.Person">Person</a></code></dt>
<dd>The Person instance. If no match is found, None is returned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_person_by_id(self, id: str):
    &#34;&#34;&#34;Get the Person instance associated with a given ID

    Args:
        id (str): The Webex ID of the Person to look for.

    Returns:
        Person: The Person instance. If no match is found, None is returned

    &#34;&#34;&#34;
    for person in self.people:
        if person.id == id:
            return person
    return None</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_pickup_groups"><code class="name flex">
<span>def <span class="ident">get_pickup_groups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all of the Call Pickup Groups for an Organization.</p>
<p>Also stores them in the Org.pickup_groups attribute.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.PickupGroup" href="#wxcadm.PickupGroup">PickupGroup</a>]</code></dt>
<dd>List of Call Pickup Groups as a list of dictionaries.</dd>
</dl>
<p>See the PickupGroup class for attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pickup_groups(self):
    &#34;&#34;&#34;Get all of the Call Pickup Groups for an Organization.

    Also stores them in the Org.pickup_groups attribute.

    Returns:
        list[PickupGroup]: List of Call Pickup Groups as a list of dictionaries.
        See the PickupGroup class for attributes.

    &#34;&#34;&#34;
    logging.info(&#34;get_pickup_groups() started&#34;)
    self.pickup_groups = []
    # First we need to know if we already have locations, because they are needed
    # for the pickup groups call
    if not self.locations:
        self.get_locations()
    # Loop through all of the locations and get their pickup groups
    # We will create a new instance of the PickupGroup class when we find one
    for location in self.locations:
        r = requests.get(_url_base + &#34;v1/telephony/config/locations/&#34; + location.id + &#34;/callPickups&#34;,
                         headers=self._headers)
        response = r.json()
        for item in response[&#39;callPickups&#39;]:
            pg = PickupGroup(self, location.id, item[&#39;id&#39;], item[&#39;name&#39;])
            self.pickup_groups.append(pg)
    return self.pickup_groups</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_workspaces"><code class="name flex">
<span>def <span class="ident">get_workspaces</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Workspaces and Workspace Locations for the Organizations.</p>
<p>Also stores them in the Org.workspaces and Org.workspace_locations attributes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.Workspace" href="#wxcadm.Workspace">Workspace</a>]</code></dt>
<dd>List of Workspace instance objects. See the Workspace class for attributes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_workspaces(self):
    &#34;&#34;&#34;Get the Workspaces and Workspace Locations for the Organizations.

    Also stores them in the Org.workspaces and Org.workspace_locations attributes.

    Returns:
        list[Workspace]: List of Workspace instance objects. See the Workspace class for attributes.

    &#34;&#34;&#34;
    logging.info(&#34;Getting Workspaces&#34;)
    self.workspaces = []
    r = requests.get(_url_base + &#34;v1/workspaces&#34;, headers=self._headers, params=self._params)
    response = r.json()
    for workspace in response[&#39;items&#39;]:
        this_workspace = Workspace(self, workspace[&#39;id&#39;], workspace)
        self.workspaces.append(this_workspace)

    logging.info(&#34;Getting Workspace Locations&#34;)
    self.workspace_locations = []
    r = requests.get(_url_base + &#34;v1/workspaceLocations&#34;, headers=self._headers, params=self._params)
    response = r.json()
    for location in response[&#39;items&#39;]:
        this_location = WorkspaceLocation(self, location[&#39;id&#39;], location)
        self.workspace_locations.append(this_location)

    return self.workspaces</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_wxc_people"><code class="name flex">
<span>def <span class="ident">get_wxc_people</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all of the people within the Organization <strong>who have Webex Calling</strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.Person" href="#wxcadm.Person">Person</a>]</code></dt>
<dd>List of Person instances of people who have a Webex Calling license</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wxc_people(self):
    &#34;&#34;&#34;Get all of the people within the Organization **who have Webex Calling**

    Returns:
        list[Person]: List of Person instances of people who have a Webex Calling license

    &#34;&#34;&#34;
    if not self.people:
        self.get_people()
    wxc_people = []
    for person in self.people:
        if person.wxc:
            wxc_people.append(person)
    return wxc_people</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_wxc_person_license"><code class="name flex">
<span>def <span class="ident">get_wxc_person_license</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Webex Calling - Professional license ID</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The License ID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wxc_person_license(self):
    &#34;&#34;&#34;Get the Webex Calling - Professional license ID

    Returns:
        str: The License ID

    &#34;&#34;&#34;
    logging.info(&#34;__get_wxc_person_license started to find available license&#34;)
    for license in self.licenses:
        if license[&#39;wxc_type&#39;] == &#34;person&#34;:
            return license[&#39;id&#39;]
    raise LicenseError(&#34;No Webex Calling Professional license found&#34;)</code></pre>
</details>
</dd>
<dt id="wxcadm.Org.get_xsi_endpoints"><code class="name flex">
<span>def <span class="ident">get_xsi_endpoints</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the XSI endpoints for the Organization.</p>
<p>Also stores them in the Org.xsi attribute.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Org.xsi attribute dictionary with each endpoint as an entry.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xsi_endpoints(self):
    &#34;&#34;&#34;Get the XSI endpoints for the Organization.

    Also stores them in the Org.xsi attribute.

    Returns:
        dict: Org.xsi attribute dictionary with each endpoint as an entry.

    &#34;&#34;&#34;
    params = {&#34;callingData&#34;: &#34;true&#34;, **self._params}
    r = requests.get(_url_base + &#34;v1/organizations/&#34; + self.id, headers=self._headers, params=params)
    response = r.json()
    if &#34;xsiActionsEndpoint&#34; in response:
        self.xsi[&#39;actions_endpoint&#39;] = response[&#39;xsiActionsEndpoint&#39;]
        self.xsi[&#39;events_endpoint&#39;] = response[&#39;xsiEventsEndpoint&#39;]
        self.xsi[&#39;events_channel_endpoint&#39;] = response[&#39;xsiEventsChannelEndpoint&#39;]
    else:
        raise XSIError(&#34;XSI requested but not present in Org. Contact Cisco TAC to enable XSI.&#34;)
    return self.xsi</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="wxcadm.Webex" href="#wxcadm.Webex">Webex</a></b></code>:
<ul class="hlist">
<li><code><a title="wxcadm.Webex.get_org_by_name" href="#wxcadm.Webex.get_org_by_name">get_org_by_name</a></code></li>
<li><code><a title="wxcadm.Webex.headers" href="#wxcadm.Webex.headers">headers</a></code></li>
<li><code><a title="wxcadm.Webex.orgs" href="#wxcadm.Webex.orgs">orgs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="wxcadm.Person"><code class="flex name class">
<span>class <span class="ident">Person</span></span>
<span>(</span><span>user_id, parent:<a title="wxcadm.Org" href="#wxcadm.Org">Org</a>=None, config:dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a new Person instance. If only the <code>user_id</code> is provided, the API calls will be made to get
the config from Webex. To save on API calls, the config can be provided which will set the attributes
without an API call.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Webex ID of the person</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>object</code>, optional</dt>
<dd>The parent object that created the Person instance. Used when the Person
is created within the Org instance</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>A dictionary of raw values from the <code>GET v1/people</code> items. Not normally used
except for automated people population from the Org init.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Person:
    def __init__(self, user_id, parent: Org = None, config: dict = None):
        &#34;&#34;&#34;
        Initialize a new Person instance. If only the `user_id` is provided, the API calls will be made to get
            the config from Webex. To save on API calls, the config can be provided which will set the attributes
            without an API call.
        Args:
            user_id (str): The Webex ID of the person
            parent (object, optional): The parent object that created the Person instance. Used when the Person
                is created within the Org instance
            config (dict, optional): A dictionary of raw values from the `GET v1/people` items. Not normally used
                except for automated people population from the Org init.
        &#34;&#34;&#34;
        self.id = user_id
        &#34;&#34;&#34;The Webex ID of the Person&#34;&#34;&#34;
        self._parent = parent
        &#34;&#34;&#34;The parent instance that created this Person&#34;&#34;&#34;

        # Attributes
        self.email: str = &#34;&#34;
        &#34;&#34;&#34;The user&#39;s email address&#34;&#34;&#34;
        self.first_name: str = &#34;&#34;
        &#34;&#34;&#34;The user&#39;s first name&#34;&#34;&#34;
        self.last_name: str = &#34;&#34;
        &#34;&#34;&#34;The user&#39;s last name&#34;&#34;&#34;
        self.display_name: str = &#34;&#34;
        &#34;&#34;&#34;The user&#39;s name as displayed in Webex&#34;&#34;&#34;
        self.wxc: bool = False
        &#39;&#39;&#39;True if this is a Webex Calling User&#39;&#39;&#39;
        self.licenses: list = []
        &#34;&#34;&#34;List of licenses assigned to the person&#34;&#34;&#34;
        self.location: str = &#34;&#34;
        &#34;&#34;&#34;The Webex ID of the user&#39;s assigned location&#34;&#34;&#34;
        self.roles: list = []
        &#34;&#34;&#34;The roles assigned to this Person in Webex&#34;&#34;&#34;
        self.vm_config: dict = {}
        &#39;&#39;&#39;Dictionary of the VM config as returned by Webex API&#39;&#39;&#39;
        self.recording: dict = {}
        &#34;&#34;&#34;Dictionary of the Recording config as returned by Webex API&#34;&#34;&#34;
        self.barge_in: dict = {}
        &#34;&#34;&#34;Dictionary of Barge-In config as returned by Webex API&#34;&#34;&#34;
        self.call_forwarding: dict = {}
        &#39;&#39;&#39;Dictionary of the Call Forwarding config as returned by Webex API&#39;&#39;&#39;
        self.caller_id: dict = {}
        &#34;&#34;&#34;Dictionary of Caller ID config as returned by Webex API&#34;&#34;&#34;
        self.intercept: dict = {}
        &#34;&#34;&#34;Dictionary of Call Intercept config as returned by Webex API&#34;&#34;&#34;
        self.dnd: dict = {}
        &#34;&#34;&#34;Dictionary of DND settings as returned by Webex API&#34;&#34;&#34;
        self.calling_behavior: dict = {}
        &#34;&#34;&#34;Dictionary of Calling Behavior as returned by Webex API&#34;&#34;&#34;
        self.xsi = None
        &#34;&#34;&#34;Holds the XSI instance when created with the `start_xsi()` method.&#34;&#34;&#34;
        self.numbers: list = []
        &#34;&#34;&#34;The phone numbers for this person from Webex CI&#34;&#34;&#34;
        self.extension: str = None
        &#34;&#34;&#34;The extension for this person&#34;&#34;&#34;
        self._hunt_groups: list = []
        &#34;&#34;&#34;A list of the Hunt Group instances that this user is an Agent for&#34;&#34;&#34;
        self._call_queues: list = []
        &#34;&#34;&#34;A list of the Call Queue instances that this user is an Agent for&#34;&#34;&#34;

        # API-related attributes
        self._headers = parent._headers
        self._params = {&#34;orgId&#34;: parent.id, &#34;callingData&#34;: &#34;true&#34;}

        # If the config was passed, process it. If not, make the API call for the Person ID and then process
        if config:
            self.__process_api_data(config)
        else:
            response = self.__get_webex_data(f&#34;v1/people/{self.id}&#34;)
            self.__process_api_data(response)

    def __process_api_data(self, data: dict):
        &#34;&#34;&#34;
        Takes the API data passed as the `data` argument and parses it to the instance attributes.
        Args:
            data (dict): A dictionary of the raw data returned by the `v1/people` API call
        &#34;&#34;&#34;
        self.email = data[&#39;emails&#39;][0]
        self.extension = data.get(&#34;extension&#34;, &#34;&#34;)
        self.location = data.get(&#34;location&#34;, &#34;&#34;)
        self.display_name = data.get(&#34;displayName&#34;, &#34;&#34;)
        self.first_name = data.get(&#34;firstName&#34;, &#34;&#34;)
        self.last_name = data.get(&#34;lastName&#34;, &#34;&#34;)
        self.roles = data.get(&#34;roles&#34;, [])
        self.numbers = data.get(&#34;phoneNumbers&#34;, [])
        self.licenses = data.get(&#34;licenses&#34;, [])
        for license in self.licenses:
            if license in self._parent.wxc_licenses:
                self.wxc = True

    def __str__(self):
        return f&#34;{self.email},{self.display_name}&#34;

    def __repr__(self):
        return self.id

    # The following is to simplify the API call. Eventually I may open this as a public method to
    # allow arbitrary API calls
    def __get_webex_data(self, endpoint: str, params: dict = None):
        &#34;&#34;&#34;
        Issue a GET to the Webex API
        Args:
            endpoint (str): The endpoint of the call (i.e. &#34;v1/people&#34; or &#34;/v1/people/{Person.id}&#34;)
            params (dict): Any additional params to be passed in the query (i.e. {&#34;callingData&#34;:&#34;true&#34;}
        Returns:
            dict: The response from the Webex API
        &#34;&#34;&#34;
        if params is None:
            params = {}
        logging.info(f&#34;__get_webex_data started for using {endpoint}&#34;)
        my_params = {**params, **self._params}
        r = requests.get(_url_base + endpoint, headers=self._headers, params=my_params)
        if r.status_code in [200]:
            response = r.json()
            return response
        else:
            return False

    def __put_webex_data(self, endpoint: str, payload: dict, params: dict = None):
        &#34;&#34;&#34;
        Issue a PUT to the Webex API
        Args:
            endpoint: The endpoint of the call (i.e. &#34;v1/people&#34; or &#34;/v1/people/{Person.id}&#34;)
            payload: A dict to send as the JSON payload of the PUT
            params: Any additional params to be passed in the query (i.e. {&#34;callingData&#34;:&#34;true&#34;}
        Returns:
            bool: True if successful, False if not
        &#34;&#34;&#34;
        if params is None:
            params = {}
        logging.info(f&#34;__put_webex_data started using {endpoint}&#34;)
        my_params = {**params, **self._params}
        r = requests.put(_url_base + endpoint, headers=self._headers, params=my_params, json=payload)
        response_code = r.status_code
        if response_code == 200 or response_code == 204:
            logging.info(&#34;Push successful&#34;)
            return True
        else:
            logging.info(&#34;Push failed&#34;)
            raise PutError(r.text)

    @property
    def spark_id(self):
        user_id_bytes = base64.b64decode(self.id + &#34;===&#34;)
        spark_id = user_id_bytes.decode(&#34;utf-8&#34;)
        return spark_id

    def assign_wxc(self, location: Location, phone_number: str = None, extension: str = None):
        &#34;&#34;&#34;
        Assign Webex Calling to the user, along with a phone number and/or an extension.

        Args:
            location (Location): The Location instance to assign the Person to.
            phone_number (str, optional): The phone number to assign to the Person.
            extension (str, optional): The extension to assign to the Person

        Returns:
            bool: True on success, False if otherwise
        &#34;&#34;&#34;
        # To assign Webex Calling to a Person, we need to find the License ID for Webex Calling Professional
        license = self._parent.get_wxc_person_license()
        self.licenses.append(license)

        # Call the update_person() method to update the new values.
        success = self.update_person(numbers=[{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: phone_number}],
                                     extension=extension, location=location.id)
        if success:
            return True
        else:
            return False

    def start_xsi(self):
        &#34;&#34;&#34;Starts an XSI session for the Person&#34;&#34;&#34;
        self.xsi = XSI(self)
        return self.xsi

    def reset_vm_pin(self, pin: str = None):
        &#34;&#34;&#34;Resets the user&#39;s voicemail PIN. If no PIN is provided, the reset command is sent, and assumes that
            a default PIN exists for the organization. Because of the operation of Webex, if a PIN is provided, the
            method will temporarily set the Org-wide PIN to the chosen PIN, then does the reset, then un-sets the
            Org default in Control Hub. ***This can cause unintended consequences if a PIN is provided and the Org
            already has a default PIN** because that PIN will be un-set at the end of this method.

            Args:
                pin (str): The new temporary PIN to set for the Person
        &#34;&#34;&#34;
        self._parent._cpapi.reset_vm_pin(self, pin=pin)

    def get_full_config(self):
        &#34;&#34;&#34;Fetches all of the Webex Calling settings for the Person. Due to the number of API calls, this
            method is not performed automatically on Person init and should be called for each Person during
            any subsequent processing. If you are only interested in one of the features, calling that method
            directly can significantly improve the time to return data.
        &#34;&#34;&#34;
        logging.info(f&#34;Getting the full config for {self.email}&#34;)
        if self.wxc:
            self.get_call_forwarding()
            self.get_vm_config()
            self.get_intercept()
            self.get_call_recording()
            self.get_caller_id()
            self.get_dnd()
            self.get_calling_behavior()
            self.get_barge_in()
            return self
        else:
            logging.info(f&#34;{self.email} is not a Webex Calling user.&#34;)

    @property
    def hunt_groups(self):
        &#34;&#34;&#34;
        The Hunt Groups that this user is an Agent for.
        Returns:
            list[HuntGroup]: A list of the `HuntGroup` instances the user belongs to
        &#34;&#34;&#34;
        # First, we need to make sure we know about the Org&#39;s Hunt Groups. If not, pull them.
        if self._parent.hunt_groups is None:
            self._parent.get_hunt_groups()
        hunt_groups = []
        for hg in self._parent.hunt_groups:
            # Step through the agents for the Hunt Group to see if this person is there
            for agent in hg.agents:
                if agent[&#39;id&#39;] == self.id:
                    hunt_groups.append(hg)
        self._hunt_groups = hunt_groups
        return self._hunt_groups

    @property
    def call_queues(self):
        &#34;&#34;&#34;
        The Call Queues that this user is an Agent for.
        Returns:
            list[CallQueue]: A list of the `CallQueue` instances the user belongs to
        &#34;&#34;&#34;
        # First, we need to make sure we know about the Org&#39;s Hunt Groups. If not, pull them.
        if self._parent.call_queues is None:
            self._parent.get_call_queues()
        call_queues = []
        for cq in self._parent.call_queues:
            # Step through the agents for the Hunt Group to see if this person is there
            for agent in cq.config[&#39;agents&#39;]:
                if agent[&#39;id&#39;] == self.id:
                    call_queues.append(cq)
        self._call_queues = call_queues
        return self._call_queues

    def get_call_forwarding(self):
        &#34;&#34;&#34;Fetch the Call Forwarding config for the Person from the Webex API&#34;&#34;&#34;
        logging.info(&#34;get_call_forwarding() started&#34;)
        self.call_forwarding = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callForwarding&#34;)
        return self.call_forwarding

    def get_barge_in(self):
        &#34;&#34;&#34;Fetch the Barge-In config for the Person from the Webex API&#34;&#34;&#34;
        logging.info(&#34;get_barge_in() started&#34;)
        self.barge_in = self.__get_webex_data(f&#34;v1/people/{self.id}/features/bargeIn&#34;)
        return self.barge_in

    def get_vm_config(self):
        &#34;&#34;&#34;Fetch the Voicemail config for the Person from the Webex API&#34;&#34;&#34;
        logging.info(&#34;get_vm_config() started&#34;)
        self.vm_config = self.__get_webex_data(f&#34;v1/people/{self.id}/features/voicemail&#34;)
        return self.vm_config

    def push_vm_config(self):
        &#34;&#34;&#34;Pushes the current Person.vm_config attributes back to Webex&#34;&#34;&#34;
        logging.info(f&#34;Pushing VM Config for {self.email}&#34;)
        success = self.__put_webex_data(f&#34;v1/people/{self.id}/features/voicemail&#34;, self.vm_config)
        if success:
            self.get_vm_config()
            return self.vm_config

    def enable_vm_to_email(self, email: str = None, push=True):
        &#34;&#34;&#34;
        Change the Voicemail config to enable sending a copy of VMs to specified email address. If the email param
            is not present, it will use the Person&#39;s email address as the default.
        Args:
            email (optional): The email address to send VMs to.
            push (optional): Whether to immediately push the change to Webex. Defaults to True.
        Returns:
            dict: The `Person.vm_config` attribute
        &#34;&#34;&#34;
        if email is None:
            email = self.email
        self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;enabled&#39;] = True
        self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;emailId&#39;] = email
        if push:
            return self.push_vm_config()
        else:
            return self.vm_config

    def disable_vm_to_email(self, push=True):
        self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;enabled&#39;] = False
        if push:
            return self.push_vm_config()
        else:
            return self.vm_config

    def get_intercept(self):
        logging.info(&#34;get_intercept() started&#34;)
        self.intercept = self.__get_webex_data(f&#34;v1/people/{self.id}/features/intercept&#34;)
        return self.intercept

    def get_call_recording(self):
        logging.info(&#34;get_call_recording() started&#34;)
        self.recording = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callRecording&#34;)
        return self.recording

    def get_caller_id(self):
        logging.info(&#34;get_caller_id() started&#34;)
        self.caller_id = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callerId&#34;)
        return self.caller_id

    def get_dnd(self):
        logging.info(f&#34;Getting DND for {self.email}&#34;)
        self.dnd = self.__get_webex_data(f&#34;v1/people/{self.id}/features/doNotDisturb&#34;)
        return self.dnd

    def get_calling_behavior(self):
        logging.info(f&#34;Getting Calling Behavior for {self.email}&#34;)
        self.calling_behavior = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callingBehavior&#34;)
        return self.calling_behavior

    def license_details(self):
        &#34;&#34;&#34;
        Get the full details for all of the licenses assigned to the Person
        Returns:
            list[dict]: List of the license dictionaries
        &#34;&#34;&#34;
        license_list = []
        for license in self.licenses:
            for org_lic in self._parent.licenses:
                if license == org_lic[&#39;id&#39;]:
                    license_list.append(org_lic)
        return license_list

    def refresh_person(self, raw: bool = False):
        &#34;&#34;&#34;
        Pull a fresh copy of the Person details from the Webex API and update the instance. Useful when changes
            are made outside of the script or changes have been pushed and need to get updated info.
        Args:
            raw (bool, optional): Return the &#34;raw&#34; config from the as a dict. Useful when making changes to
                the user, because you have to send all of the values over again.
        Returns:
            bool: True if successful, False if not
        &#34;&#34;&#34;
        response = self.__get_webex_data(f&#34;v1/people/{self.id}&#34;)
        if response:
            self.__process_api_data(response)
            if raw:
                return response
            else:
                return True
        else:
            return False

    def update_person(self,
                      email=None,
                      numbers=None,
                      extension=None,
                      location=None,
                      display_name=None,
                      first_name=None,
                      last_name=None,
                      roles=None,
                      licenses=None):
        &#34;&#34;&#34;
        Update the Person in Webex. Pass only the arguments that you want to change. Other attributes will be populated
            with the existing values from the instance. *Note:* This allows changes directly to the instance attrs to
            be pushed to Webex. For example, changing Person.extension and then calling `update_person()` with no
            arguments will still push the extension change. This allows for a lot of flexibility if a method does not
            exist to change the desired value. It is also the method other methods use to push their changes to Webex.
        Args:
            email (str): The email address of the Person
            numbers (list): The list of number dicts (&#34;type&#34; and &#34;value&#34; keys)
            extension (str): The user&#39;s extension
            location (str): The Location ID for the user. Note that this can&#39;t actually be changed yet.
            display_name (str): The Display Name for the Person
            first_name (str): The Person&#39;s first name
            last_name (str): The Person&#39;s last name
            roles (list): List of Role IDs
            licenses (list): List of License IDs
        Returns:
            bool: True if successful. False if not.
        &#34;&#34;&#34;
        # Build the payload using the arguments and the instance attrs
        payload = {}
        if email is None:
            email = self.email
        payload[&#39;emails&#39;] = [email]
        if numbers is None:
            numbers = self.numbers
        payload[&#39;phoneNumbers&#39;] = numbers
        if extension is None:
            if self.extension:
                extension = self.extension
        payload[&#39;extension&#39;] = extension
        if location is None:
            location = self.location
        payload[&#39;location&#39;] = location
        if display_name is None:
            display_name = self.display_name
        payload[&#39;displayName&#39;] = display_name
        if first_name is None:
            first_name = self.first_name
        payload[&#39;firstName&#39;] = first_name
        if last_name is None:
            last_name = self.last_name
        payload[&#39;lastName&#39;] = last_name
        if roles is None:
            roles = self.roles
        payload[&#39;roles&#39;] = roles
        if licenses is None:
            licenses = self.licenses
        payload[&#39;licenses&#39;] = licenses

        params = {&#34;callingData&#34;: &#34;true&#34;}
        success = self.__put_webex_data(f&#34;v1/people/{self.id}&#34;, payload, params)
        if success:
            self.refresh_person()
            return True
        else:
            return False

    def set_calling_only(self):
        &#34;&#34;&#34;
        Removes the Messaging and Meetings licenses, leaving only the Calling capability.

        Returns:
            Person: The instance of this person with the updated values

        &#34;&#34;&#34;
        logging.info(f&#34;Setting {self.email} to Calling-Only&#34;)
        # First, iterate the existing licenses and remove the ones we don&#39;t want
        # Build a list that contains the values to match on to remove
        remove_matches = [&#34;messaging&#34;,
                          &#34;meeting&#34;,
                          &#34;free&#34;]
        new_licenses = []
        for license in self.licenses:
            logging.debug(f&#34;Checking license: {license}&#34;)
            lic_name = self._parent.get_license_name(license)
            logging.debug(f&#34;License Name: {lic_name}&#34;)
            if any(match in lic_name.lower() for match in remove_matches):
                if &#34;screen share&#34; in lic_name.lower():
                    logging.debug(f&#34;{lic_name} matches but is needed&#34;)
                    new_licenses.append(license)
                else:
                    logging.debug(f&#34;License should be removed&#34;)
                    continue
            else:
                logging.debug(f&#34;Keeping license&#34;)
                new_licenses.append(license)

        success = self.update_person(licenses=new_licenses)
        return self

    def change_phone_number(self, new_number: str, new_extension: str = None):
        &#34;&#34;&#34;
        Change a person&#39;s phone number and extension
        Args:
            new_number (str): The new phone number for the person
            new_extension (str, optional): The new extension, if changing. Omit to leave the same value.
        Returns:
            Person: The instance of this person, with the new values
        &#34;&#34;&#34;
        if not new_extension:
            if self.extension:
                extension = self.extension
            else:
                extension = None
        else:
            extension = new_extension

        # Call the update_person() method
        success = self.update_person(numbers=[{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: new_number}], extension=extension)
        return self</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.Person.barge_in"><code class="name">var <span class="ident">barge_in</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of Barge-In config as returned by Webex API</p></div>
</dd>
<dt id="wxcadm.Person.call_forwarding"><code class="name">var <span class="ident">call_forwarding</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of the Call Forwarding config as returned by Webex API</p></div>
</dd>
<dt id="wxcadm.Person.call_queues"><code class="name">var <span class="ident">call_queues</span></code></dt>
<dd>
<div class="desc"><p>The Call Queues that this user is an Agent for.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.CallQueue" href="#wxcadm.CallQueue">CallQueue</a>]</code></dt>
<dd>A list of the <code><a title="wxcadm.CallQueue" href="#wxcadm.CallQueue">CallQueue</a></code> instances the user belongs to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def call_queues(self):
    &#34;&#34;&#34;
    The Call Queues that this user is an Agent for.
    Returns:
        list[CallQueue]: A list of the `CallQueue` instances the user belongs to
    &#34;&#34;&#34;
    # First, we need to make sure we know about the Org&#39;s Hunt Groups. If not, pull them.
    if self._parent.call_queues is None:
        self._parent.get_call_queues()
    call_queues = []
    for cq in self._parent.call_queues:
        # Step through the agents for the Hunt Group to see if this person is there
        for agent in cq.config[&#39;agents&#39;]:
            if agent[&#39;id&#39;] == self.id:
                call_queues.append(cq)
    self._call_queues = call_queues
    return self._call_queues</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.caller_id"><code class="name">var <span class="ident">caller_id</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of Caller ID config as returned by Webex API</p></div>
</dd>
<dt id="wxcadm.Person.calling_behavior"><code class="name">var <span class="ident">calling_behavior</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of Calling Behavior as returned by Webex API</p></div>
</dd>
<dt id="wxcadm.Person.display_name"><code class="name">var <span class="ident">display_name</span></code></dt>
<dd>
<div class="desc"><p>The user's name as displayed in Webex</p></div>
</dd>
<dt id="wxcadm.Person.dnd"><code class="name">var <span class="ident">dnd</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of DND settings as returned by Webex API</p></div>
</dd>
<dt id="wxcadm.Person.email"><code class="name">var <span class="ident">email</span></code></dt>
<dd>
<div class="desc"><p>The user's email address</p></div>
</dd>
<dt id="wxcadm.Person.extension"><code class="name">var <span class="ident">extension</span></code></dt>
<dd>
<div class="desc"><p>The extension for this person</p></div>
</dd>
<dt id="wxcadm.Person.first_name"><code class="name">var <span class="ident">first_name</span></code></dt>
<dd>
<div class="desc"><p>The user's first name</p></div>
</dd>
<dt id="wxcadm.Person.hunt_groups"><code class="name">var <span class="ident">hunt_groups</span></code></dt>
<dd>
<div class="desc"><p>The Hunt Groups that this user is an Agent for.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.HuntGroup" href="#wxcadm.HuntGroup">HuntGroup</a>]</code></dt>
<dd>A list of the <code><a title="wxcadm.HuntGroup" href="#wxcadm.HuntGroup">HuntGroup</a></code> instances the user belongs to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hunt_groups(self):
    &#34;&#34;&#34;
    The Hunt Groups that this user is an Agent for.
    Returns:
        list[HuntGroup]: A list of the `HuntGroup` instances the user belongs to
    &#34;&#34;&#34;
    # First, we need to make sure we know about the Org&#39;s Hunt Groups. If not, pull them.
    if self._parent.hunt_groups is None:
        self._parent.get_hunt_groups()
    hunt_groups = []
    for hg in self._parent.hunt_groups:
        # Step through the agents for the Hunt Group to see if this person is there
        for agent in hg.agents:
            if agent[&#39;id&#39;] == self.id:
                hunt_groups.append(hg)
    self._hunt_groups = hunt_groups
    return self._hunt_groups</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Person</p></div>
</dd>
<dt id="wxcadm.Person.intercept"><code class="name">var <span class="ident">intercept</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of Call Intercept config as returned by Webex API</p></div>
</dd>
<dt id="wxcadm.Person.last_name"><code class="name">var <span class="ident">last_name</span></code></dt>
<dd>
<div class="desc"><p>The user's last name</p></div>
</dd>
<dt id="wxcadm.Person.licenses"><code class="name">var <span class="ident">licenses</span></code></dt>
<dd>
<div class="desc"><p>List of licenses assigned to the person</p></div>
</dd>
<dt id="wxcadm.Person.location"><code class="name">var <span class="ident">location</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the user's assigned location</p></div>
</dd>
<dt id="wxcadm.Person.numbers"><code class="name">var <span class="ident">numbers</span></code></dt>
<dd>
<div class="desc"><p>The phone numbers for this person from Webex CI</p></div>
</dd>
<dt id="wxcadm.Person.recording"><code class="name">var <span class="ident">recording</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of the Recording config as returned by Webex API</p></div>
</dd>
<dt id="wxcadm.Person.roles"><code class="name">var <span class="ident">roles</span></code></dt>
<dd>
<div class="desc"><p>The roles assigned to this Person in Webex</p></div>
</dd>
<dt id="wxcadm.Person.spark_id"><code class="name">var <span class="ident">spark_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spark_id(self):
    user_id_bytes = base64.b64decode(self.id + &#34;===&#34;)
    spark_id = user_id_bytes.decode(&#34;utf-8&#34;)
    return spark_id</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.vm_config"><code class="name">var <span class="ident">vm_config</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of the VM config as returned by Webex API</p></div>
</dd>
<dt id="wxcadm.Person.wxc"><code class="name">var <span class="ident">wxc</span></code></dt>
<dd>
<div class="desc"><p>True if this is a Webex Calling User</p></div>
</dd>
<dt id="wxcadm.Person.xsi"><code class="name">var <span class="ident">xsi</span></code></dt>
<dd>
<div class="desc"><p>Holds the XSI instance when created with the <code>start_xsi()</code> method.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.Person.assign_wxc"><code class="name flex">
<span>def <span class="ident">assign_wxc</span></span>(<span>self, location:<a title="wxcadm.Location" href="#wxcadm.Location">Location</a>, phone_number:str=None, extension:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign Webex Calling to the user, along with a phone number and/or an extension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong> :&ensp;<code><a title="wxcadm.Location" href="#wxcadm.Location">Location</a></code></dt>
<dd>The Location instance to assign the Person to.</dd>
<dt><strong><code>phone_number</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The phone number to assign to the Person.</dd>
<dt><strong><code>extension</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extension to assign to the Person</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True on success, False if otherwise</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_wxc(self, location: Location, phone_number: str = None, extension: str = None):
    &#34;&#34;&#34;
    Assign Webex Calling to the user, along with a phone number and/or an extension.

    Args:
        location (Location): The Location instance to assign the Person to.
        phone_number (str, optional): The phone number to assign to the Person.
        extension (str, optional): The extension to assign to the Person

    Returns:
        bool: True on success, False if otherwise
    &#34;&#34;&#34;
    # To assign Webex Calling to a Person, we need to find the License ID for Webex Calling Professional
    license = self._parent.get_wxc_person_license()
    self.licenses.append(license)

    # Call the update_person() method to update the new values.
    success = self.update_person(numbers=[{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: phone_number}],
                                 extension=extension, location=location.id)
    if success:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.change_phone_number"><code class="name flex">
<span>def <span class="ident">change_phone_number</span></span>(<span>self, new_number:str, new_extension:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change a person's phone number and extension</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_number</code></strong> :&ensp;<code>str</code></dt>
<dd>The new phone number for the person</dd>
<dt><strong><code>new_extension</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The new extension, if changing. Omit to leave the same value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Person" href="#wxcadm.Person">Person</a></code></dt>
<dd>The instance of this person, with the new values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_phone_number(self, new_number: str, new_extension: str = None):
    &#34;&#34;&#34;
    Change a person&#39;s phone number and extension
    Args:
        new_number (str): The new phone number for the person
        new_extension (str, optional): The new extension, if changing. Omit to leave the same value.
    Returns:
        Person: The instance of this person, with the new values
    &#34;&#34;&#34;
    if not new_extension:
        if self.extension:
            extension = self.extension
        else:
            extension = None
    else:
        extension = new_extension

    # Call the update_person() method
    success = self.update_person(numbers=[{&#34;type&#34;: &#34;work&#34;, &#34;value&#34;: new_number}], extension=extension)
    return self</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.disable_vm_to_email"><code class="name flex">
<span>def <span class="ident">disable_vm_to_email</span></span>(<span>self, push=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_vm_to_email(self, push=True):
    self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;enabled&#39;] = False
    if push:
        return self.push_vm_config()
    else:
        return self.vm_config</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.enable_vm_to_email"><code class="name flex">
<span>def <span class="ident">enable_vm_to_email</span></span>(<span>self, email:str=None, push=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the Voicemail config to enable sending a copy of VMs to specified email address. If the email param
is not present, it will use the Person's email address as the default.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>email</code></strong> :&ensp;<code>optional</code></dt>
<dd>The email address to send VMs to.</dd>
<dt><strong><code>push</code></strong> :&ensp;<code>optional</code></dt>
<dd>Whether to immediately push the change to Webex. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The <code><a title="wxcadm.Person.vm_config" href="#wxcadm.Person.vm_config">Person.vm_config</a></code> attribute</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_vm_to_email(self, email: str = None, push=True):
    &#34;&#34;&#34;
    Change the Voicemail config to enable sending a copy of VMs to specified email address. If the email param
        is not present, it will use the Person&#39;s email address as the default.
    Args:
        email (optional): The email address to send VMs to.
        push (optional): Whether to immediately push the change to Webex. Defaults to True.
    Returns:
        dict: The `Person.vm_config` attribute
    &#34;&#34;&#34;
    if email is None:
        email = self.email
    self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;enabled&#39;] = True
    self.vm_config[&#39;emailCopyOfMessage&#39;][&#39;emailId&#39;] = email
    if push:
        return self.push_vm_config()
    else:
        return self.vm_config</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_barge_in"><code class="name flex">
<span>def <span class="ident">get_barge_in</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch the Barge-In config for the Person from the Webex API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_barge_in(self):
    &#34;&#34;&#34;Fetch the Barge-In config for the Person from the Webex API&#34;&#34;&#34;
    logging.info(&#34;get_barge_in() started&#34;)
    self.barge_in = self.__get_webex_data(f&#34;v1/people/{self.id}/features/bargeIn&#34;)
    return self.barge_in</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_call_forwarding"><code class="name flex">
<span>def <span class="ident">get_call_forwarding</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch the Call Forwarding config for the Person from the Webex API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_call_forwarding(self):
    &#34;&#34;&#34;Fetch the Call Forwarding config for the Person from the Webex API&#34;&#34;&#34;
    logging.info(&#34;get_call_forwarding() started&#34;)
    self.call_forwarding = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callForwarding&#34;)
    return self.call_forwarding</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_call_recording"><code class="name flex">
<span>def <span class="ident">get_call_recording</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_call_recording(self):
    logging.info(&#34;get_call_recording() started&#34;)
    self.recording = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callRecording&#34;)
    return self.recording</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_caller_id"><code class="name flex">
<span>def <span class="ident">get_caller_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_caller_id(self):
    logging.info(&#34;get_caller_id() started&#34;)
    self.caller_id = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callerId&#34;)
    return self.caller_id</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_calling_behavior"><code class="name flex">
<span>def <span class="ident">get_calling_behavior</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calling_behavior(self):
    logging.info(f&#34;Getting Calling Behavior for {self.email}&#34;)
    self.calling_behavior = self.__get_webex_data(f&#34;v1/people/{self.id}/features/callingBehavior&#34;)
    return self.calling_behavior</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_dnd"><code class="name flex">
<span>def <span class="ident">get_dnd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dnd(self):
    logging.info(f&#34;Getting DND for {self.email}&#34;)
    self.dnd = self.__get_webex_data(f&#34;v1/people/{self.id}/features/doNotDisturb&#34;)
    return self.dnd</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_full_config"><code class="name flex">
<span>def <span class="ident">get_full_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches all of the Webex Calling settings for the Person. Due to the number of API calls, this
method is not performed automatically on Person init and should be called for each Person during
any subsequent processing. If you are only interested in one of the features, calling that method
directly can significantly improve the time to return data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_full_config(self):
    &#34;&#34;&#34;Fetches all of the Webex Calling settings for the Person. Due to the number of API calls, this
        method is not performed automatically on Person init and should be called for each Person during
        any subsequent processing. If you are only interested in one of the features, calling that method
        directly can significantly improve the time to return data.
    &#34;&#34;&#34;
    logging.info(f&#34;Getting the full config for {self.email}&#34;)
    if self.wxc:
        self.get_call_forwarding()
        self.get_vm_config()
        self.get_intercept()
        self.get_call_recording()
        self.get_caller_id()
        self.get_dnd()
        self.get_calling_behavior()
        self.get_barge_in()
        return self
    else:
        logging.info(f&#34;{self.email} is not a Webex Calling user.&#34;)</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_intercept"><code class="name flex">
<span>def <span class="ident">get_intercept</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intercept(self):
    logging.info(&#34;get_intercept() started&#34;)
    self.intercept = self.__get_webex_data(f&#34;v1/people/{self.id}/features/intercept&#34;)
    return self.intercept</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.get_vm_config"><code class="name flex">
<span>def <span class="ident">get_vm_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch the Voicemail config for the Person from the Webex API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vm_config(self):
    &#34;&#34;&#34;Fetch the Voicemail config for the Person from the Webex API&#34;&#34;&#34;
    logging.info(&#34;get_vm_config() started&#34;)
    self.vm_config = self.__get_webex_data(f&#34;v1/people/{self.id}/features/voicemail&#34;)
    return self.vm_config</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.license_details"><code class="name flex">
<span>def <span class="ident">license_details</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the full details for all of the licenses assigned to the Person</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict]</code></dt>
<dd>List of the license dictionaries</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def license_details(self):
    &#34;&#34;&#34;
    Get the full details for all of the licenses assigned to the Person
    Returns:
        list[dict]: List of the license dictionaries
    &#34;&#34;&#34;
    license_list = []
    for license in self.licenses:
        for org_lic in self._parent.licenses:
            if license == org_lic[&#39;id&#39;]:
                license_list.append(org_lic)
    return license_list</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.push_vm_config"><code class="name flex">
<span>def <span class="ident">push_vm_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pushes the current Person.vm_config attributes back to Webex</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_vm_config(self):
    &#34;&#34;&#34;Pushes the current Person.vm_config attributes back to Webex&#34;&#34;&#34;
    logging.info(f&#34;Pushing VM Config for {self.email}&#34;)
    success = self.__put_webex_data(f&#34;v1/people/{self.id}/features/voicemail&#34;, self.vm_config)
    if success:
        self.get_vm_config()
        return self.vm_config</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.refresh_person"><code class="name flex">
<span>def <span class="ident">refresh_person</span></span>(<span>self, raw:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pull a fresh copy of the Person details from the Webex API and update the instance. Useful when changes
are made outside of the script or changes have been pushed and need to get updated info.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Return the "raw" config from the as a dict. Useful when making changes to
the user, because you have to send all of the values over again.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if successful, False if not</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_person(self, raw: bool = False):
    &#34;&#34;&#34;
    Pull a fresh copy of the Person details from the Webex API and update the instance. Useful when changes
        are made outside of the script or changes have been pushed and need to get updated info.
    Args:
        raw (bool, optional): Return the &#34;raw&#34; config from the as a dict. Useful when making changes to
            the user, because you have to send all of the values over again.
    Returns:
        bool: True if successful, False if not
    &#34;&#34;&#34;
    response = self.__get_webex_data(f&#34;v1/people/{self.id}&#34;)
    if response:
        self.__process_api_data(response)
        if raw:
            return response
        else:
            return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.reset_vm_pin"><code class="name flex">
<span>def <span class="ident">reset_vm_pin</span></span>(<span>self, pin:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the user's voicemail PIN. If no PIN is provided, the reset command is sent, and assumes that
a default PIN exists for the organization. Because of the operation of Webex, if a PIN is provided, the
method will temporarily set the Org-wide PIN to the chosen PIN, then does the reset, then un-sets the
Org default in Control Hub. <strong>*This can cause unintended consequences if a PIN is provided and the Org
already has a default PIN</strong> because that PIN will be un-set at the end of this method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pin</code></strong> :&ensp;<code>str</code></dt>
<dd>The new temporary PIN to set for the Person</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_vm_pin(self, pin: str = None):
    &#34;&#34;&#34;Resets the user&#39;s voicemail PIN. If no PIN is provided, the reset command is sent, and assumes that
        a default PIN exists for the organization. Because of the operation of Webex, if a PIN is provided, the
        method will temporarily set the Org-wide PIN to the chosen PIN, then does the reset, then un-sets the
        Org default in Control Hub. ***This can cause unintended consequences if a PIN is provided and the Org
        already has a default PIN** because that PIN will be un-set at the end of this method.

        Args:
            pin (str): The new temporary PIN to set for the Person
    &#34;&#34;&#34;
    self._parent._cpapi.reset_vm_pin(self, pin=pin)</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.set_calling_only"><code class="name flex">
<span>def <span class="ident">set_calling_only</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the Messaging and Meetings licenses, leaving only the Calling capability.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Person" href="#wxcadm.Person">Person</a></code></dt>
<dd>The instance of this person with the updated values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_calling_only(self):
    &#34;&#34;&#34;
    Removes the Messaging and Meetings licenses, leaving only the Calling capability.

    Returns:
        Person: The instance of this person with the updated values

    &#34;&#34;&#34;
    logging.info(f&#34;Setting {self.email} to Calling-Only&#34;)
    # First, iterate the existing licenses and remove the ones we don&#39;t want
    # Build a list that contains the values to match on to remove
    remove_matches = [&#34;messaging&#34;,
                      &#34;meeting&#34;,
                      &#34;free&#34;]
    new_licenses = []
    for license in self.licenses:
        logging.debug(f&#34;Checking license: {license}&#34;)
        lic_name = self._parent.get_license_name(license)
        logging.debug(f&#34;License Name: {lic_name}&#34;)
        if any(match in lic_name.lower() for match in remove_matches):
            if &#34;screen share&#34; in lic_name.lower():
                logging.debug(f&#34;{lic_name} matches but is needed&#34;)
                new_licenses.append(license)
            else:
                logging.debug(f&#34;License should be removed&#34;)
                continue
        else:
            logging.debug(f&#34;Keeping license&#34;)
            new_licenses.append(license)

    success = self.update_person(licenses=new_licenses)
    return self</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.start_xsi"><code class="name flex">
<span>def <span class="ident">start_xsi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts an XSI session for the Person</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_xsi(self):
    &#34;&#34;&#34;Starts an XSI session for the Person&#34;&#34;&#34;
    self.xsi = XSI(self)
    return self.xsi</code></pre>
</details>
</dd>
<dt id="wxcadm.Person.update_person"><code class="name flex">
<span>def <span class="ident">update_person</span></span>(<span>self, email=None, numbers=None, extension=None, location=None, display_name=None, first_name=None, last_name=None, roles=None, licenses=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the Person in Webex. Pass only the arguments that you want to change. Other attributes will be populated
with the existing values from the instance. <em>Note:</em> This allows changes directly to the instance attrs to
be pushed to Webex. For example, changing Person.extension and then calling <code>update_person()</code> with no
arguments will still push the extension change. This allows for a lot of flexibility if a method does not
exist to change the desired value. It is also the method other methods use to push their changes to Webex.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code></dt>
<dd>The email address of the Person</dd>
<dt><strong><code>numbers</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of number dicts ("type" and "value" keys)</dd>
<dt><strong><code>extension</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's extension</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>str</code></dt>
<dd>The Location ID for the user. Note that this can't actually be changed yet.</dd>
<dt><strong><code>display_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The Display Name for the Person</dd>
<dt><strong><code>first_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The Person's first name</dd>
<dt><strong><code>last_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The Person's last name</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Role IDs</dd>
<dt><strong><code>licenses</code></strong> :&ensp;<code>list</code></dt>
<dd>List of License IDs</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if successful. False if not.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_person(self,
                  email=None,
                  numbers=None,
                  extension=None,
                  location=None,
                  display_name=None,
                  first_name=None,
                  last_name=None,
                  roles=None,
                  licenses=None):
    &#34;&#34;&#34;
    Update the Person in Webex. Pass only the arguments that you want to change. Other attributes will be populated
        with the existing values from the instance. *Note:* This allows changes directly to the instance attrs to
        be pushed to Webex. For example, changing Person.extension and then calling `update_person()` with no
        arguments will still push the extension change. This allows for a lot of flexibility if a method does not
        exist to change the desired value. It is also the method other methods use to push their changes to Webex.
    Args:
        email (str): The email address of the Person
        numbers (list): The list of number dicts (&#34;type&#34; and &#34;value&#34; keys)
        extension (str): The user&#39;s extension
        location (str): The Location ID for the user. Note that this can&#39;t actually be changed yet.
        display_name (str): The Display Name for the Person
        first_name (str): The Person&#39;s first name
        last_name (str): The Person&#39;s last name
        roles (list): List of Role IDs
        licenses (list): List of License IDs
    Returns:
        bool: True if successful. False if not.
    &#34;&#34;&#34;
    # Build the payload using the arguments and the instance attrs
    payload = {}
    if email is None:
        email = self.email
    payload[&#39;emails&#39;] = [email]
    if numbers is None:
        numbers = self.numbers
    payload[&#39;phoneNumbers&#39;] = numbers
    if extension is None:
        if self.extension:
            extension = self.extension
    payload[&#39;extension&#39;] = extension
    if location is None:
        location = self.location
    payload[&#39;location&#39;] = location
    if display_name is None:
        display_name = self.display_name
    payload[&#39;displayName&#39;] = display_name
    if first_name is None:
        first_name = self.first_name
    payload[&#39;firstName&#39;] = first_name
    if last_name is None:
        last_name = self.last_name
    payload[&#39;lastName&#39;] = last_name
    if roles is None:
        roles = self.roles
    payload[&#39;roles&#39;] = roles
    if licenses is None:
        licenses = self.licenses
    payload[&#39;licenses&#39;] = licenses

    params = {&#34;callingData&#34;: &#34;true&#34;}
    success = self.__put_webex_data(f&#34;v1/people/{self.id}&#34;, payload, params)
    if success:
        self.refresh_person()
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.PickupGroup"><code class="flex name class">
<span>class <span class="ident">PickupGroup</span></span>
<span>(</span><span>parent, location, id, name, users=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PickupGroup:
    def __init__(self, parent, location, id, name, users=None):
        self._parent: object = parent
        self.location_id: str = location
        &#34;&#34;&#34;The Webex ID of the Location associated with this Pickup Group&#34;&#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Pickup Group&#34;&#34;&#34;
        self.name: str = name
        &#34;&#34;&#34;The name of the Pickup Group&#34;&#34;&#34;
        self.users: list = []
        &#34;&#34;&#34;All of the users (agents) assigned to this Pickup Group&#34;&#34;&#34;
        # If no agents were passed, we need to go get the configuration of the PickupGroup
        if users is None:
            r = requests.get(_url_base + f&#34;v1/telephony/config/locations/{self.location_id}/callPickups/{self.id}&#34;,
                             headers=self._parent._headers
                             )
            response = r.json()
            # TODO It doesn&#39;t make sense to create a new Person instance for the below.
            #      Once we have an API and a class for Workspaces, it would make sense to tie
            #      the agents to the Person or Workspace instance
            # For now, we just write the values that we get back and the user can find the people with the
            # Person-specific methods
            for agent in response[&#39;agents&#39;]:
                self.users.append(agent)

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    def get_config(self):
        &#34;&#34;&#34;Gets the configuration of the Pickup Group from Webex
        Returns:
            dict: The configuration of the Pickup Group
        &#34;&#34;&#34;
        config = {**self}
        return config</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.PickupGroup.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Pickup Group</p></div>
</dd>
<dt id="wxcadm.PickupGroup.location_id"><code class="name">var <span class="ident">location_id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Location associated with this Pickup Group</p></div>
</dd>
<dt id="wxcadm.PickupGroup.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of the Pickup Group</p></div>
</dd>
<dt id="wxcadm.PickupGroup.users"><code class="name">var <span class="ident">users</span></code></dt>
<dd>
<div class="desc"><p>All of the users (agents) assigned to this Pickup Group</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.PickupGroup.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the configuration of the Pickup Group from Webex</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The configuration of the Pickup Group</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    &#34;&#34;&#34;Gets the configuration of the Pickup Group from Webex
    Returns:
        dict: The configuration of the Pickup Group
    &#34;&#34;&#34;
    config = {**self}
    return config</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.Webex"><code class="flex name class">
<span>class <span class="ident">Webex</span></span>
<span>(</span><span>access_token:str, create_org:bool=True, get_people:bool=True, get_locations:bool=True, get_xsi:bool=False, get_hunt_groups:bool=False, get_call_queues:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class for working with wxcadm.</p>
<p>Initialize a Webex instance to communicate with Webex and store data</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>access_token</code></strong> :&ensp;<code>str</code></dt>
<dd>The Webex API Access Token to authenticate the API calls</dd>
<dt><strong><code>create_org</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to create an Org instance for all organizations.</dd>
<dt><strong><code>get_people</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get all of the People and created instances for them</dd>
<dt><strong><code>get_locations</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get all Locations and create instances for them</dd>
<dt><strong><code>get_xsi</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get the XSI endpoints for each Org. Defaults to False, since
not every Org has XSI capability</dd>
<dt><strong><code>get_hunt_groups</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get the Hunt Groups for each Org. Defaults to False.</dd>
<dt><strong><code>get_call_queues</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to get the Call Queues for each Org. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Webex" href="#wxcadm.Webex">Webex</a></code></dt>
<dd>The Webex instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Webex:
    # TODO List
    #    Add token refresh, just for completeness. For now, we don&#39;t mess with tokens at all.
    &#34;&#34;&#34;The base class for working with wxcadm.

    &#34;&#34;&#34;

    def __init__(self,
                 access_token: str,
                 create_org: bool = True,
                 get_people: bool = True,
                 get_locations: bool = True,
                 get_xsi: bool = False,
                 get_hunt_groups: bool = False,
                 get_call_queues: bool = False
                 ) -&gt; None:
        &#34;&#34;&#34;Initialize a Webex instance to communicate with Webex and store data

        Args:
            access_token (str): The Webex API Access Token to authenticate the API calls
            create_org (bool, optional): Whether to create an Org instance for all organizations.
            get_people (bool, optional): Whether to get all of the People and created instances for them
            get_locations (bool, optional): Whether to get all Locations and create instances for them
            get_xsi (bool, optional): Whether to get the XSI endpoints for each Org. Defaults to False, since
                not every Org has XSI capability
            get_hunt_groups (bool, optional): Whether to get the Hunt Groups for each Org. Defaults to False.
            get_call_queues (bool, optional): Whether to get the Call Queues for each Org. Defaults to False.

        Returns:
            Webex: The Webex instance

        &#34;&#34;&#34;
        logging.info(&#34;Webex instance initialized&#34;)
        # The access token is the only thing that we need to get started
        self._access_token: str = access_token
        # The Authorization header is going to be used by every API call in the package.
        # Might want to make it something global so we don&#39;t have to inherit it across all of the children
        self._headers: dict = {&#34;Authorization&#34;: &#34;Bearer &#34; + access_token}
        logging.debug(f&#34;Setting Org._headers to {self._headers}&#34;)

        # Instance attrs
        self.orgs: list[Org] = []
        &#39;&#39;&#39;A list of the Org instances that this Webex instance can manage&#39;&#39;&#39;
        # Get the orgs that this token can manage
        logging.debug(f&#34;Making API call to v1/organizations&#34;)
        r = requests.get(_url_base + &#34;v1/organizations&#34;, headers=self._headers)
        # Handle an invalid access token
        if r.status_code != 200:
            raise TokenError(&#34;The Access Token was not accepted by Webex&#34;)
        response = r.json()
        # Handle when no Orgs are returned. This is pretty rare
        if len(response[&#39;items&#39;]) == 0:
            raise OrgError
        # If a token can manage a lot of orgs, you might not want to create them all, because
        # it can take some time to do all of the API calls and get the data back
        if not create_org:
            logging.info(&#34;Org initialization not requested. Storing orgs.&#34;)
            self.orgs = response[&#39;items&#39;]
            return
        else:
            logging.info(&#34;Org initialization requested. Collecting orgs&#34;)
            for org in response[&#39;items&#39;]:
                # This builds an Org instance for every Org, so be careful
                # if the user manages multiple orgs
                logging.debug(f&#34;Processing org: {org[&#39;displayName&#39;]}&#34;)
                org = Org(org[&#39;displayName&#39;], org[&#39;id&#39;],
                          people=get_people, locations=get_locations, xsi=get_xsi, parent=self,
                          call_queues=get_call_queues, hunt_groups=get_hunt_groups)
                self.orgs.append(org)
            # Most users have only one org, so to make that easier for them to work with
            # we are also going to put the orgs[0] instance in the org attr
            # That way both .org and .orgs[0] are the same
            if len(self.orgs) == 1:
                logging.debug(f&#34;Only one org found. Storing as Webex.org&#34;)
                self.org = self.orgs[0]

    @property
    def headers(self):
        &#34;&#34;&#34;The &#34;universal&#34; HTTP headers with the Authorization header present&#34;&#34;&#34;
        return self._headers

    def get_org_by_name(self, name: str):
        &#34;&#34;&#34;Get the Org instance that matches all or part of the name argument.

        Args:
            name (str): Text to match against the Org name

        Returns:
            Org: The Org instance of the matching Org

        Raises:
            KeyError: Raised when no match is made

        &#34;&#34;&#34;
        for org in self.orgs:
            if name in org.name:
                return org
        raise KeyError(&#34;Org not found&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="wxcadm.Org" href="#wxcadm.Org">Org</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.Webex.headers"><code class="name">var <span class="ident">headers</span></code></dt>
<dd>
<div class="desc"><p>The "universal" HTTP headers with the Authorization header present</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def headers(self):
    &#34;&#34;&#34;The &#34;universal&#34; HTTP headers with the Authorization header present&#34;&#34;&#34;
    return self._headers</code></pre>
</details>
</dd>
<dt id="wxcadm.Webex.orgs"><code class="name">var <span class="ident">orgs</span></code></dt>
<dd>
<div class="desc"><p>A list of the Org instances that this Webex instance can manage</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.Webex.get_org_by_name"><code class="name flex">
<span>def <span class="ident">get_org_by_name</span></span>(<span>self, name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Org instance that matches all or part of the name argument.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Text to match against the Org name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Org" href="#wxcadm.Org">Org</a></code></dt>
<dd>The Org instance of the matching Org</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Raised when no match is made</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_org_by_name(self, name: str):
    &#34;&#34;&#34;Get the Org instance that matches all or part of the name argument.

    Args:
        name (str): Text to match against the Org name

    Returns:
        Org: The Org instance of the matching Org

    Raises:
        KeyError: Raised when no match is made

    &#34;&#34;&#34;
    for org in self.orgs:
        if name in org.name:
            return org
    raise KeyError(&#34;Org not found&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.Workspace"><code class="flex name class">
<span>class <span class="ident">Workspace</span></span>
<span>(</span><span>parent:<a title="wxcadm.Org" href="#wxcadm.Org">Org</a>, id:str, config:dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a Workspace instance. If only the <code>id</code> is provided, the configuration will be fetched from
the Webex API. To save API calls, the config dict can be passed using the <code>config</code> argument</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="wxcadm.Org" href="#wxcadm.Org">Org</a></code></dt>
<dd>The Organization to which this workspace belongs</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Webex ID of the Workspace</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>The configuration of the Workspace as returned by the Webex API</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Workspace:
    def __init__(self, parent: Org, id: str, config: dict = None):
        &#34;&#34;&#34;Initialize a Workspace instance. If only the `id` is provided, the configuration will be fetched from
            the Webex API. To save API calls, the config dict can be passed using the `config` argument
        Args:
            parent (Org): The Organization to which this workspace belongs
            id (str): The Webex ID of the Workspace
            config (dict): The configuration of the Workspace as returned by the Webex API
        &#34;&#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Workspace&#34;&#34;&#34;
        self._parent: Org = parent
        # Attributes inherited from the Org parent
        self._headers = self._parent._headers
        self._params = self._parent._params
        # Instance attributes
        self.location: str = None
        &#34;&#34;&#34;The Webex ID of the Workspace Location (note this is a Workspace Location, not a Calling Location.&#34;&#34;&#34;
        self.floor: str = None
        &#34;&#34;&#34;The Webex ID of the Floor ID&#34;&#34;&#34;
        self.name: str = &#34;&#34;
        &#34;&#34;&#34;The name of the Workspace&#34;&#34;&#34;
        self.capacity: int = None
        &#34;&#34;&#34;The capacity of the Workspace&#34;&#34;&#34;
        self.type: str = None
        &#34;&#34;&#34;
        The type of Workspace. Valid values are:
        
            &#34;notSet&#34;: No value set
            &#34;focus&#34;: High concentration
            &#34;huddle&#34;: Brainstorm/collaboration
            &#34;meetingRoom&#34;: Dedicated meeting space
            &#34;open&#34;: Unstructured agile
            &#34;desk&#34;: Individual
            &#34;other&#34;: Unspecified
        &#34;&#34;&#34;
        self.sip_address: str = None
        &#34;&#34;&#34;The SIP Address used to call to the Workspace&#34;&#34;&#34;
        self.created: str = None
        &#34;&#34;&#34;The date and time the workspace was created&#34;&#34;&#34;
        self.calling: str = None
        &#34;&#34;&#34;
        The type of Calling license assigned to the Workspace. Valid values are:
        
            &#39;freeCalling&#39;: Free Calling
            &#39;hybridCalling&#39;: Hybrid Calling
            &#39;webexCalling&#39;: Webex Calling
            &#39;webexEdgeForDevices&#39;: Webex Edge for Devices
        &#34;&#34;&#34;
        self.calendar: dict = None
        &#34;&#34;&#34;The type of calendar connector assigned to the Workspace&#34;&#34;&#34;
        self.notes: str = None
        &#34;&#34;&#34;Notes associated with the Workspace&#34;&#34;&#34;

        if config:
            self.__process_config(config)
        else:
            self.get_config()

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.id

    @property
    def spark_id(self):
        bytes = base64.b64decode(self.id + &#34;===&#34;)
        spark_id = bytes.decode(&#34;utf-8&#34;)
        return spark_id

    def get_config(self):
        &#34;&#34;&#34;Get (or refresh) the confirmation of the Workspace from the Webex API&#34;&#34;&#34;
        logging.info(f&#34;Getting Workspace config for {self.id}&#34;)
        r = requests.get(_url_base + f&#34;v1/workspaces/{self.id}&#34;, headers=self._headers, params=self._params)
        if r.status_code in [200]:
            response = r.json()
            self.__process_config(response)
        else:
            raise APIError(f&#34;Unable to fetch workspace config for {self.id}&#34;)

    def __process_config(self, config: dict):
        &#34;&#34;&#34;Processes the config dict, whether passed in init or from an API call&#34;&#34;&#34;
        self.name = config.get(&#34;displayName&#34;, &#34;&#34;)
        self.location = config.get(&#34;workspaceLocationId&#34;, &#34;&#34;)
        self.floor = config.get(&#34;floorId&#34;, &#34;&#34;)
        self.capacity = config.get(&#34;capacity&#34;, 0)
        self.type = config[&#39;type&#39;]
        self.sip_address = config.get(&#34;sipAddress&#34;, &#34;&#34;)
        self.created = config.get(&#34;created&#34;, &#34;&#34;)
        if &#34;calling&#34; in config:
            self.calling = config[&#39;calling&#39;][&#39;type&#39;]
        else:
            self.calling = &#34;None&#34;
        self.calendar = config[&#39;calendar&#39;]
        self.notes = config.get(&#34;notes&#34;, &#34;&#34;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.Workspace.calendar"><code class="name">var <span class="ident">calendar</span></code></dt>
<dd>
<div class="desc"><p>The type of calendar connector assigned to the Workspace</p></div>
</dd>
<dt id="wxcadm.Workspace.calling"><code class="name">var <span class="ident">calling</span></code></dt>
<dd>
<div class="desc"><p>The type of Calling license assigned to the Workspace. Valid values are:</p>
<pre><code>'freeCalling': Free Calling
'hybridCalling': Hybrid Calling
'webexCalling': Webex Calling
'webexEdgeForDevices': Webex Edge for Devices
</code></pre></div>
</dd>
<dt id="wxcadm.Workspace.capacity"><code class="name">var <span class="ident">capacity</span></code></dt>
<dd>
<div class="desc"><p>The capacity of the Workspace</p></div>
</dd>
<dt id="wxcadm.Workspace.created"><code class="name">var <span class="ident">created</span></code></dt>
<dd>
<div class="desc"><p>The date and time the workspace was created</p></div>
</dd>
<dt id="wxcadm.Workspace.floor"><code class="name">var <span class="ident">floor</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Floor ID</p></div>
</dd>
<dt id="wxcadm.Workspace.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Workspace</p></div>
</dd>
<dt id="wxcadm.Workspace.location"><code class="name">var <span class="ident">location</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Workspace Location (note this is a Workspace Location, not a Calling Location.</p></div>
</dd>
<dt id="wxcadm.Workspace.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of the Workspace</p></div>
</dd>
<dt id="wxcadm.Workspace.notes"><code class="name">var <span class="ident">notes</span></code></dt>
<dd>
<div class="desc"><p>Notes associated with the Workspace</p></div>
</dd>
<dt id="wxcadm.Workspace.sip_address"><code class="name">var <span class="ident">sip_address</span></code></dt>
<dd>
<div class="desc"><p>The SIP Address used to call to the Workspace</p></div>
</dd>
<dt id="wxcadm.Workspace.spark_id"><code class="name">var <span class="ident">spark_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spark_id(self):
    bytes = base64.b64decode(self.id + &#34;===&#34;)
    spark_id = bytes.decode(&#34;utf-8&#34;)
    return spark_id</code></pre>
</details>
</dd>
<dt id="wxcadm.Workspace.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>The type of Workspace. Valid values are:</p>
<pre><code>"notSet": No value set
"focus": High concentration
"huddle": Brainstorm/collaboration
"meetingRoom": Dedicated meeting space
"open": Unstructured agile
"desk": Individual
"other": Unspecified
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.Workspace.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get (or refresh) the confirmation of the Workspace from the Webex API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    &#34;&#34;&#34;Get (or refresh) the confirmation of the Workspace from the Webex API&#34;&#34;&#34;
    logging.info(f&#34;Getting Workspace config for {self.id}&#34;)
    r = requests.get(_url_base + f&#34;v1/workspaces/{self.id}&#34;, headers=self._headers, params=self._params)
    if r.status_code in [200]:
        response = r.json()
        self.__process_config(response)
    else:
        raise APIError(f&#34;Unable to fetch workspace config for {self.id}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.WorkspaceLocation"><code class="flex name class">
<span>class <span class="ident">WorkspaceLocation</span></span>
<span>(</span><span>parent:<a title="wxcadm.Org" href="#wxcadm.Org">Org</a>, id:str, config:dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a WorkspaceLocation instance.</p>
<p>If only the <code>id</code> is provided, the configuration will be fetched from
the Webex API. To save API calls, the config dict can be passed using the <code>config</code> argument</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="wxcadm.Org" href="#wxcadm.Org">Org</a></code></dt>
<dd>The Organization to which this WorkspaceLocation belongs</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>The Webex ID of the WorkspaceLocation</dd>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>The configuration of the WorkspaceLocation as returned by the Webex API</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkspaceLocation:
    def __init__(self, parent: Org, id: str, config: dict = None):
        &#34;&#34;&#34;Initialize a WorkspaceLocation instance.

        If only the `id` is provided, the configuration will be fetched from
            the Webex API. To save API calls, the config dict can be passed using the `config` argument

        Args:
            parent (Org): The Organization to which this WorkspaceLocation belongs
            id (str): The Webex ID of the WorkspaceLocation
            config (dict): The configuration of the WorkspaceLocation as returned by the Webex API

        &#34;&#34;&#34;
        self.id: str = id
        &#34;&#34;&#34;The Webex ID of the Workspace&#34;&#34;&#34;
        self._parent: Org = parent
        # Attributes inherited from the Org parent
        self._headers = self._parent._headers
        self._params = self._parent._params
        # Instance attributes
        self.name: str = None
        &#34;&#34;&#34;The name of the WorkspaceLocation&#34;&#34;&#34;
        self.address: str = None
        &#34;&#34;&#34;The address of the WorkspaceLocation&#34;&#34;&#34;
        self.country: str = None
        &#34;&#34;&#34;The country code (ISO 3166-1) for the WorkspaceLocation&#34;&#34;&#34;
        self.city: str = None
        &#34;&#34;&#34;The city name where the WorkspaceLocation is located&#34;&#34;&#34;
        self.latitude: float = None
        &#34;&#34;&#34;The WorkspaceLocation latitude&#34;&#34;&#34;
        self.longitude: float = None
        &#34;&#34;&#34;The WorkspaceLocation longitude&#34;&#34;&#34;
        self.notes: str = None
        &#34;&#34;&#34;Notes associated with the WorkspaceLocation&#34;&#34;&#34;
        self.floors: list[WorkspaceLocationFloor] = None

        if config:
            self.__process_config(config)
        else:
            self.get_config()
        self.get_floors()

    def get_config(self):
        &#34;&#34;&#34;Get (or refresh) the configuration of the WorkspaceLocations from the Webex API&#34;&#34;&#34;
        logging.info(f&#34;Getting Workspace config for {self.id}&#34;)
        r = requests.get(_url_base + f&#34;v1/workspaceLocations/{self.id}&#34;, headers=self._headers, params=self._params)
        if r.status_code in [200]:
            response = r.json()
            self.__process_config(response)
        else:
            raise APIError(f&#34;Unable to fetch workspace config for {self.id}&#34;)

    def get_floors(self):
        &#34;&#34;&#34;Get (or refresh) the WorkspaceLocationFloor instances for this WorkspaceLocation&#34;&#34;&#34;
        logging.info(f&#34;Getting Location Floors for {self.name}&#34;)
        self.floors = []
        r = requests.get(_url_base + f&#34;v1/workspaceLocations/{self.id}/floors&#34;,
                         headers=self._headers, params=self._params)
        response = r.json()
        for floor in response[&#39;items&#39;]:
            this_floor = WorkspaceLocationFloor(floor)
            self.floors.append(this_floor)

    def __process_config(self, config: dict):
        &#34;&#34;&#34;Processes the config dict, whether passed in init or from an API call&#34;&#34;&#34;
        self.name = config.get(&#34;displayName&#34;, &#34;&#34;)
        self.address = config.get(&#34;address&#34;, &#34;&#34;)
        self.country = config.get(&#34;countryCode&#34;, &#34;&#34;)
        self.city = config.get(&#34;cityName&#34;, &#34;&#34;)
        self.latitude = config.get(&#34;latitude&#34;, &#34;&#34;)
        self.longitude = config.get(&#34;longitude&#34;, &#34;&#34;)
        self.notes = config.get(&#34;notes&#34;, &#34;&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="wxcadm.WorkspaceLocationFloor" href="#wxcadm.WorkspaceLocationFloor">WorkspaceLocationFloor</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.WorkspaceLocation.address"><code class="name">var <span class="ident">address</span></code></dt>
<dd>
<div class="desc"><p>The address of the WorkspaceLocation</p></div>
</dd>
<dt id="wxcadm.WorkspaceLocation.city"><code class="name">var <span class="ident">city</span></code></dt>
<dd>
<div class="desc"><p>The city name where the WorkspaceLocation is located</p></div>
</dd>
<dt id="wxcadm.WorkspaceLocation.country"><code class="name">var <span class="ident">country</span></code></dt>
<dd>
<div class="desc"><p>The country code (ISO 3166-1) for the WorkspaceLocation</p></div>
</dd>
<dt id="wxcadm.WorkspaceLocation.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>The Webex ID of the Workspace</p></div>
</dd>
<dt id="wxcadm.WorkspaceLocation.latitude"><code class="name">var <span class="ident">latitude</span></code></dt>
<dd>
<div class="desc"><p>The WorkspaceLocation latitude</p></div>
</dd>
<dt id="wxcadm.WorkspaceLocation.longitude"><code class="name">var <span class="ident">longitude</span></code></dt>
<dd>
<div class="desc"><p>The WorkspaceLocation longitude</p></div>
</dd>
<dt id="wxcadm.WorkspaceLocation.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The name of the WorkspaceLocation</p></div>
</dd>
<dt id="wxcadm.WorkspaceLocation.notes"><code class="name">var <span class="ident">notes</span></code></dt>
<dd>
<div class="desc"><p>Notes associated with the WorkspaceLocation</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.WorkspaceLocation.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get (or refresh) the configuration of the WorkspaceLocations from the Webex API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    &#34;&#34;&#34;Get (or refresh) the configuration of the WorkspaceLocations from the Webex API&#34;&#34;&#34;
    logging.info(f&#34;Getting Workspace config for {self.id}&#34;)
    r = requests.get(_url_base + f&#34;v1/workspaceLocations/{self.id}&#34;, headers=self._headers, params=self._params)
    if r.status_code in [200]:
        response = r.json()
        self.__process_config(response)
    else:
        raise APIError(f&#34;Unable to fetch workspace config for {self.id}&#34;)</code></pre>
</details>
</dd>
<dt id="wxcadm.WorkspaceLocation.get_floors"><code class="name flex">
<span>def <span class="ident">get_floors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get (or refresh) the WorkspaceLocationFloor instances for this WorkspaceLocation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_floors(self):
    &#34;&#34;&#34;Get (or refresh) the WorkspaceLocationFloor instances for this WorkspaceLocation&#34;&#34;&#34;
    logging.info(f&#34;Getting Location Floors for {self.name}&#34;)
    self.floors = []
    r = requests.get(_url_base + f&#34;v1/workspaceLocations/{self.id}/floors&#34;,
                     headers=self._headers, params=self._params)
    response = r.json()
    for floor in response[&#39;items&#39;]:
        this_floor = WorkspaceLocationFloor(floor)
        self.floors.append(this_floor)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wxcadm.WorkspaceLocationFloor"><code class="flex name class">
<span>class <span class="ident">WorkspaceLocationFloor</span></span>
<span>(</span><span>config:dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a new WorkspaceLocationFloor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dict</code></dt>
<dd>The config as returned by the Webex API</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkspaceLocationFloor(WorkspaceLocation):
    def __init__(self, config: dict):
        &#34;&#34;&#34;Initialize a new WorkspaceLocationFloor

        Args:
            config (dict): The config as returned by the Webex API

        &#34;&#34;&#34;
        self.name = config.get(&#34;displayName&#34;)
        self.id = config.get(&#34;id&#34;)
        self.floor = config.get(&#34;floorNumber&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wxcadm.WorkspaceLocation" href="#wxcadm.WorkspaceLocation">WorkspaceLocation</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="wxcadm.WorkspaceLocation" href="#wxcadm.WorkspaceLocation">WorkspaceLocation</a></b></code>:
<ul class="hlist">
<li><code><a title="wxcadm.WorkspaceLocation.address" href="#wxcadm.WorkspaceLocation.address">address</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.city" href="#wxcadm.WorkspaceLocation.city">city</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.country" href="#wxcadm.WorkspaceLocation.country">country</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.get_config" href="#wxcadm.WorkspaceLocation.get_config">get_config</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.get_floors" href="#wxcadm.WorkspaceLocation.get_floors">get_floors</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.id" href="#wxcadm.WorkspaceLocation.id">id</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.latitude" href="#wxcadm.WorkspaceLocation.latitude">latitude</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.longitude" href="#wxcadm.WorkspaceLocation.longitude">longitude</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.name" href="#wxcadm.WorkspaceLocation.name">name</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.notes" href="#wxcadm.WorkspaceLocation.notes">notes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="wxcadm.XSI"><code class="flex name class">
<span>class <span class="ident">XSI</span></span>
<span>(</span><span>parent, get_profile:bool=False, cache:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The XSI class holds all of the relevant XSI data for a Person</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="wxcadm.Person" href="#wxcadm.Person">Person</a></code></dt>
<dd>The Person who this XSI instance belongs to</dd>
<dt><strong><code>get_profile</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to automatically get the XSI Profile</dd>
<dt><strong><code>cache</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to cache the XSI data (True) or pull it "live" every time (<strong>False</strong>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XSI:
    def __init__(self, parent, get_profile: bool = False, cache: bool = False):
        &#34;&#34;&#34;
        The XSI class holds all of the relevant XSI data for a Person
        Args:
            parent (Person): The Person who this XSI instance belongs to
            get_profile (bool): Whether or not to automatically get the XSI Profile
            cache (bool): Whether to cache the XSI data (True) or pull it &#34;live&#34; every time (**False**)
        &#34;&#34;&#34;
        logging.info(f&#34;Initializing XSI instance for {parent.email}&#34;)
        # First we need to get the XSI User ID for the Webex person we are working with
        logging.info(&#34;Getting XSI identifiers&#34;)
        user_id_bytes = base64.b64decode(parent.id + &#34;===&#34;)
        user_id_decoded = user_id_bytes.decode(&#34;utf-8&#34;)
        user_id_bwks = user_id_decoded.split(&#34;/&#34;)[-1]
        self.id = user_id_bwks

        # Inherited attributes
        self.xsi_endpoints = parent._parent.xsi
        self._cache = cache

        # API attributes
        self._headers = {&#34;Content-Type&#34;: &#34;application/json&#34;,
                         &#34;Accept&#34;: &#34;application/json&#34;,
                         &#34;X-BroadWorks-Protocol-Version&#34;: &#34;25.0&#34;,
                         **parent._headers}
        self._params = {&#34;format&#34;: &#34;json&#34;}

        # Attribute definitions
        self._calls: list = []
        self._profile: dict = {}
        &#34;&#34;&#34;The XSI Profile for this Person&#34;&#34;&#34;
        self._registrations: dict = {}
        &#34;&#34;&#34;The Registrations associated with this Person&#34;&#34;&#34;
        self.fac = None
        self.services = {}
        self._alternate_numbers: dict = {}
        &#34;&#34;&#34;The Alternate Numbers for the Person&#34;&#34;&#34;
        self._anonymous_call_rejection: dict = {}
        &#34;&#34;&#34;The Anonymous Call Rejection settings for this Person&#34;&#34;&#34;
        self._single_number_reach: dict = {}
        &#34;&#34;&#34;The SNR (Office Anywhere) settings for this Person&#34;&#34;&#34;
        self._monitoring: dict = {}
        &#34;&#34;&#34;The BLF/Monitoring settings for this Person&#34;&#34;&#34;
        self.conference: object = None

        # Get the profile if we have been asked to
        if get_profile:
            self.get_profile()

    def new_call(self, address: str = None):
        &#34;&#34;&#34;
        Create a new Call instance
        Args:
            address (str, optional): The address to originate a call to
        Returns:
            Call: The Call instance
        &#34;&#34;&#34;
        # If we got an address, pass it to the new instance
        if address is not None:
            call = Call(self, address=address)
        else:
            call = Call(self)
        self._calls.append(call)
        return call

    def new_conference(self, calls: list = [], comment: str = &#34;&#34;):
        &#34;&#34;&#34;
        Crates a new Conference instance. A user can only have one Conference instance, so this will replace any
        previous Conference. At the moment, this **should not be called directly** and will be done dynamically by
        a Call.conference()
        Args:
            calls (list): A list of Call IDs involved in this conference. A conference is always started with only
                two Call IDs. Call IDs after the first two will be ignored.
            comment (str, optional): An optional text comment for the conference
        Returns:
            The instance of the Conference class
        &#34;&#34;&#34;
        self.conference = Conference(self, calls, comment)
        return self.conference

    @property
    def calls(self):
        &#34;&#34;&#34;
        Get the list of active calls and creates Call instances. Also destroys any Call instances that are no longer
        valid.
        Returns:
            list[Call]: List of Call instances
        &#34;&#34;&#34;
        # First wipe out all of the existing instances
        for call in self._calls:
            del call
        self._calls.clear()
        calls_data: list = self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/calls&#34;)
        logging.debug(f&#34;Calls Data: {calls_data}&#34;)
        if &#34;call&#34; not in calls_data[&#39;Calls&#39;]:
            self._calls = []
            return self._calls
        if type(calls_data[&#39;Calls&#39;][&#39;call&#39;]) is dict:
            this_call = Call(self, id=calls_data[&#39;Calls&#39;][&#39;call&#39;][&#39;callId&#39;][&#39;$&#39;])
            self._calls.append(this_call)
        elif type(calls_data[&#39;Calls&#39;][&#39;call&#39;]) is list:
            for call in calls_data[&#39;Calls&#39;][&#39;call&#39;]:
                this_call = Call(self, id=call[&#39;callId&#39;][&#39;$&#39;])
                self._calls.append(this_call)
        return self._calls

    def __get_xsi_data(self, url, params: dict = {}):
        params = {**params, **self._params}
        r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + url, headers=self._headers, params=params)
        if r.status_code == 200:
            try:
                response = r.json()
            except json.decoder.JSONDecodeError:
                response = r.text
            return_data = response
        elif r.status_code == 404:
            return_data = False
        return return_data

    @property
    def monitoring(self):
        &#34;&#34;&#34;The Monitoring/BLF settings for this person&#34;&#34;&#34;
        if not self._monitoring or not self._cache:
            self._monitoring = self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/BusyLampField&#34;)
        return self._monitoring

    @property
    def single_number_reach(self):
        &#34;&#34;&#34;The SNR (Office Anywhere) settings for this Person&#34;&#34;&#34;
        if not self._single_number_reach or not self._cache:
            self._single_number_reach = \
                self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/BroadWorksAnywhere&#34;)
        return self._single_number_reach

    @property
    def anonymous_call_rejection(self):
        &#34;&#34;&#34;The Anonymous Call Rejection settings for this Person&#34;&#34;&#34;
        if not self._anonymous_call_rejection or not self._cache:
            self._anonymous_call_rejection = \
                self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/AnonymousCallRejection&#34;)
        return self._anonymous_call_rejection

    @property
    def alternate_numbers(self):
        &#34;&#34;&#34;The Alternate Numbers for this Person&#34;&#34;&#34;
        if not self._alternate_numbers or not self._cache:
            self._alternate_numbers = \
                self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/AlternateNumbers&#34;)
        return self._alternate_numbers

    @property
    def profile(self):
        &#34;&#34;&#34;The XSI Profile for this Person&#34;&#34;&#34;
        if not self._profile or not self._cache:
            profile_data: dict = \
                self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/profile&#34;)
            # The following is a mapping of the raw XSI format to the profile attribute
            self._profile[&#39;registrations_url&#39;] = profile_data[&#39;Profile&#39;][&#39;registrations&#39;][&#39;$&#39;]
            self._profile[&#39;schedule_url&#39;] = profile_data[&#39;Profile&#39;][&#39;scheduleList&#39;][&#39;$&#39;]
            self._profile[&#39;fac_url&#39;] = profile_data[&#39;Profile&#39;][&#39;fac&#39;][&#39;$&#39;]
            self._profile[&#39;country_code&#39;] = profile_data[&#39;Profile&#39;][&#39;countryCode&#39;][&#39;$&#39;]
            self._profile[&#39;user_id&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;userId&#39;][&#39;$&#39;]
            self._profile[&#39;group_id&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;groupId&#39;][&#39;$&#39;]
            self._profile[&#39;service_provider&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;serviceProvider&#39;][&#39;$&#39;]
            # Not everyone has a number and/or extension, so we need to check to see if there are there
            if &#34;number&#34; in profile_data[&#39;Profile&#39;][&#39;details&#39;]:
                self._profile[&#39;number&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;number&#39;][&#39;$&#39;]
            if &#34;extension&#34; in profile_data[&#39;Profile&#39;][&#39;details&#39;]:
                self._profile[&#39;extension&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;extension&#39;][&#39;$&#39;]
        return self._profile

    @property
    def registrations(self):
        &#34;&#34;&#34;The device registrations associated with this Person&#34;&#34;&#34;
        if not self._registrations or not self._cache:
            # If we don&#39;t have a registrations URL, because we don&#39;t have the profile, go get it
            if &#34;registrations_url&#34; not in self._profile:
                self.profile
            self._registrations = self.__get_xsi_data(self._profile[&#39;registrations_url&#39;])
        return self._registrations

    def get_fac(self):
        # If we don&#39;t have a FAC URL, go get it
        if &#34;fac_url&#34; not in self._profile:
            self.profile()
        r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + self._profile[&#39;fac_url&#39;],
                         headers=self._headers, params=self._params)
        response = r.json()
        self.fac = response
        return self.fac

    def get_services(self):
        # TODO There are still some services that we should collect more data for. For example, BroadWorks
        #       Anywhere has Locations that aren&#39;t pulled without a separate call.

        r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + &#34;/v2.0/user/&#34; + self.id + &#34;/services&#34;,
                         headers=self._headers, params=self._params)
        response = r.json()
        self.services[&#39;list&#39;] = response[&#39;Services&#39;][&#39;service&#39;]
        # Now that we have all of the services, pulling the data is pretty easy since the URL
        # is present in the response. Loop through the services and collect the data
        # Some services have no config so there is no URI and we&#39;ll just populate them as True
        for service in self.services[&#39;list&#39;]:
            if &#34;uri&#34; in service:
                r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + service[&#39;uri&#39;][&#39;$&#39;],
                                 headers=self._headers, params=self._params)
                # Getting well-formatted JSON doesn&#39;t always work. If we can decode the JSON, use it
                # If not, just store the raw text. At some point, it would make sense to parse the text
                # and build the dict directly
                try:
                    response = r.json()
                except json.decoder.JSONDecodeError:
                    response = r.text
                self.services[service[&#39;name&#39;][&#39;$&#39;]] = response
            else:
                self.services[service[&#39;name&#39;][&#39;$&#39;]] = True
        return self.services</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wxcadm.XSI.alternate_numbers"><code class="name">var <span class="ident">alternate_numbers</span></code></dt>
<dd>
<div class="desc"><p>The Alternate Numbers for this Person</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def alternate_numbers(self):
    &#34;&#34;&#34;The Alternate Numbers for this Person&#34;&#34;&#34;
    if not self._alternate_numbers or not self._cache:
        self._alternate_numbers = \
            self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/AlternateNumbers&#34;)
    return self._alternate_numbers</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.anonymous_call_rejection"><code class="name">var <span class="ident">anonymous_call_rejection</span></code></dt>
<dd>
<div class="desc"><p>The Anonymous Call Rejection settings for this Person</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def anonymous_call_rejection(self):
    &#34;&#34;&#34;The Anonymous Call Rejection settings for this Person&#34;&#34;&#34;
    if not self._anonymous_call_rejection or not self._cache:
        self._anonymous_call_rejection = \
            self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/AnonymousCallRejection&#34;)
    return self._anonymous_call_rejection</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.calls"><code class="name">var <span class="ident">calls</span></code></dt>
<dd>
<div class="desc"><p>Get the list of active calls and creates Call instances. Also destroys any Call instances that are no longer
valid.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[<a title="wxcadm.Call" href="#wxcadm.Call">Call</a>]</code></dt>
<dd>List of Call instances</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def calls(self):
    &#34;&#34;&#34;
    Get the list of active calls and creates Call instances. Also destroys any Call instances that are no longer
    valid.
    Returns:
        list[Call]: List of Call instances
    &#34;&#34;&#34;
    # First wipe out all of the existing instances
    for call in self._calls:
        del call
    self._calls.clear()
    calls_data: list = self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/calls&#34;)
    logging.debug(f&#34;Calls Data: {calls_data}&#34;)
    if &#34;call&#34; not in calls_data[&#39;Calls&#39;]:
        self._calls = []
        return self._calls
    if type(calls_data[&#39;Calls&#39;][&#39;call&#39;]) is dict:
        this_call = Call(self, id=calls_data[&#39;Calls&#39;][&#39;call&#39;][&#39;callId&#39;][&#39;$&#39;])
        self._calls.append(this_call)
    elif type(calls_data[&#39;Calls&#39;][&#39;call&#39;]) is list:
        for call in calls_data[&#39;Calls&#39;][&#39;call&#39;]:
            this_call = Call(self, id=call[&#39;callId&#39;][&#39;$&#39;])
            self._calls.append(this_call)
    return self._calls</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.monitoring"><code class="name">var <span class="ident">monitoring</span></code></dt>
<dd>
<div class="desc"><p>The Monitoring/BLF settings for this person</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def monitoring(self):
    &#34;&#34;&#34;The Monitoring/BLF settings for this person&#34;&#34;&#34;
    if not self._monitoring or not self._cache:
        self._monitoring = self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/BusyLampField&#34;)
    return self._monitoring</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.profile"><code class="name">var <span class="ident">profile</span></code></dt>
<dd>
<div class="desc"><p>The XSI Profile for this Person</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def profile(self):
    &#34;&#34;&#34;The XSI Profile for this Person&#34;&#34;&#34;
    if not self._profile or not self._cache:
        profile_data: dict = \
            self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/profile&#34;)
        # The following is a mapping of the raw XSI format to the profile attribute
        self._profile[&#39;registrations_url&#39;] = profile_data[&#39;Profile&#39;][&#39;registrations&#39;][&#39;$&#39;]
        self._profile[&#39;schedule_url&#39;] = profile_data[&#39;Profile&#39;][&#39;scheduleList&#39;][&#39;$&#39;]
        self._profile[&#39;fac_url&#39;] = profile_data[&#39;Profile&#39;][&#39;fac&#39;][&#39;$&#39;]
        self._profile[&#39;country_code&#39;] = profile_data[&#39;Profile&#39;][&#39;countryCode&#39;][&#39;$&#39;]
        self._profile[&#39;user_id&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;userId&#39;][&#39;$&#39;]
        self._profile[&#39;group_id&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;groupId&#39;][&#39;$&#39;]
        self._profile[&#39;service_provider&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;serviceProvider&#39;][&#39;$&#39;]
        # Not everyone has a number and/or extension, so we need to check to see if there are there
        if &#34;number&#34; in profile_data[&#39;Profile&#39;][&#39;details&#39;]:
            self._profile[&#39;number&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;number&#39;][&#39;$&#39;]
        if &#34;extension&#34; in profile_data[&#39;Profile&#39;][&#39;details&#39;]:
            self._profile[&#39;extension&#39;] = profile_data[&#39;Profile&#39;][&#39;details&#39;][&#39;extension&#39;][&#39;$&#39;]
    return self._profile</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.registrations"><code class="name">var <span class="ident">registrations</span></code></dt>
<dd>
<div class="desc"><p>The device registrations associated with this Person</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def registrations(self):
    &#34;&#34;&#34;The device registrations associated with this Person&#34;&#34;&#34;
    if not self._registrations or not self._cache:
        # If we don&#39;t have a registrations URL, because we don&#39;t have the profile, go get it
        if &#34;registrations_url&#34; not in self._profile:
            self.profile
        self._registrations = self.__get_xsi_data(self._profile[&#39;registrations_url&#39;])
    return self._registrations</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.single_number_reach"><code class="name">var <span class="ident">single_number_reach</span></code></dt>
<dd>
<div class="desc"><p>The SNR (Office Anywhere) settings for this Person</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def single_number_reach(self):
    &#34;&#34;&#34;The SNR (Office Anywhere) settings for this Person&#34;&#34;&#34;
    if not self._single_number_reach or not self._cache:
        self._single_number_reach = \
            self.__get_xsi_data(f&#34;/v2.0/user/{self.id}/services/BroadWorksAnywhere&#34;)
    return self._single_number_reach</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wxcadm.XSI.get_fac"><code class="name flex">
<span>def <span class="ident">get_fac</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fac(self):
    # If we don&#39;t have a FAC URL, go get it
    if &#34;fac_url&#34; not in self._profile:
        self.profile()
    r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + self._profile[&#39;fac_url&#39;],
                     headers=self._headers, params=self._params)
    response = r.json()
    self.fac = response
    return self.fac</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.get_services"><code class="name flex">
<span>def <span class="ident">get_services</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_services(self):
    # TODO There are still some services that we should collect more data for. For example, BroadWorks
    #       Anywhere has Locations that aren&#39;t pulled without a separate call.

    r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + &#34;/v2.0/user/&#34; + self.id + &#34;/services&#34;,
                     headers=self._headers, params=self._params)
    response = r.json()
    self.services[&#39;list&#39;] = response[&#39;Services&#39;][&#39;service&#39;]
    # Now that we have all of the services, pulling the data is pretty easy since the URL
    # is present in the response. Loop through the services and collect the data
    # Some services have no config so there is no URI and we&#39;ll just populate them as True
    for service in self.services[&#39;list&#39;]:
        if &#34;uri&#34; in service:
            r = requests.get(self.xsi_endpoints[&#39;actions_endpoint&#39;] + service[&#39;uri&#39;][&#39;$&#39;],
                             headers=self._headers, params=self._params)
            # Getting well-formatted JSON doesn&#39;t always work. If we can decode the JSON, use it
            # If not, just store the raw text. At some point, it would make sense to parse the text
            # and build the dict directly
            try:
                response = r.json()
            except json.decoder.JSONDecodeError:
                response = r.text
            self.services[service[&#39;name&#39;][&#39;$&#39;]] = response
        else:
            self.services[service[&#39;name&#39;][&#39;$&#39;]] = True
    return self.services</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.new_call"><code class="name flex">
<span>def <span class="ident">new_call</span></span>(<span>self, address:str=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new Call instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The address to originate a call to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wxcadm.Call" href="#wxcadm.Call">Call</a></code></dt>
<dd>The Call instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_call(self, address: str = None):
    &#34;&#34;&#34;
    Create a new Call instance
    Args:
        address (str, optional): The address to originate a call to
    Returns:
        Call: The Call instance
    &#34;&#34;&#34;
    # If we got an address, pass it to the new instance
    if address is not None:
        call = Call(self, address=address)
    else:
        call = Call(self)
    self._calls.append(call)
    return call</code></pre>
</details>
</dd>
<dt id="wxcadm.XSI.new_conference"><code class="name flex">
<span>def <span class="ident">new_conference</span></span>(<span>self, calls:list=[], comment:str='')</span>
</code></dt>
<dd>
<div class="desc"><p>Crates a new Conference instance. A user can only have one Conference instance, so this will replace any
previous Conference. At the moment, this <strong>should not be called directly</strong> and will be done dynamically by
a Call.conference()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>calls</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of Call IDs involved in this conference. A conference is always started with only
two Call IDs. Call IDs after the first two will be ignored.</dd>
<dt><strong><code>comment</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>An optional text comment for the conference</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The instance of the Conference class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_conference(self, calls: list = [], comment: str = &#34;&#34;):
    &#34;&#34;&#34;
    Crates a new Conference instance. A user can only have one Conference instance, so this will replace any
    previous Conference. At the moment, this **should not be called directly** and will be done dynamically by
    a Call.conference()
    Args:
        calls (list): A list of Call IDs involved in this conference. A conference is always started with only
            two Call IDs. Call IDs after the first two will be ignored.
        comment (str, optional): An optional text comment for the conference
    Returns:
        The instance of the Conference class
    &#34;&#34;&#34;
    self.conference = Conference(self, calls, comment)
    return self.conference</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wxcadm.CPAPI" href="#wxcadm.CPAPI">CPAPI</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.CPAPI.clear_global_vm_pin" href="#wxcadm.CPAPI.clear_global_vm_pin">clear_global_vm_pin</a></code></li>
<li><code><a title="wxcadm.CPAPI.get_numbers" href="#wxcadm.CPAPI.get_numbers">get_numbers</a></code></li>
<li><code><a title="wxcadm.CPAPI.reset_vm_pin" href="#wxcadm.CPAPI.reset_vm_pin">reset_vm_pin</a></code></li>
<li><code><a title="wxcadm.CPAPI.set_global_vm_pin" href="#wxcadm.CPAPI.set_global_vm_pin">set_global_vm_pin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.Call" href="#wxcadm.Call">Call</a></code></h4>
<ul class="two-column">
<li><code><a title="wxcadm.Call.conference" href="#wxcadm.Call.conference">conference</a></code></li>
<li><code><a title="wxcadm.Call.finish_transfer" href="#wxcadm.Call.finish_transfer">finish_transfer</a></code></li>
<li><code><a title="wxcadm.Call.hangup" href="#wxcadm.Call.hangup">hangup</a></code></li>
<li><code><a title="wxcadm.Call.hold" href="#wxcadm.Call.hold">hold</a></code></li>
<li><code><a title="wxcadm.Call.id" href="#wxcadm.Call.id">id</a></code></li>
<li><code><a title="wxcadm.Call.originate" href="#wxcadm.Call.originate">originate</a></code></li>
<li><code><a title="wxcadm.Call.resume" href="#wxcadm.Call.resume">resume</a></code></li>
<li><code><a title="wxcadm.Call.send_dtmf" href="#wxcadm.Call.send_dtmf">send_dtmf</a></code></li>
<li><code><a title="wxcadm.Call.status" href="#wxcadm.Call.status">status</a></code></li>
<li><code><a title="wxcadm.Call.transfer" href="#wxcadm.Call.transfer">transfer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.CallQueue" href="#wxcadm.CallQueue">CallQueue</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.CallQueue.call_forwarding" href="#wxcadm.CallQueue.call_forwarding">call_forwarding</a></code></li>
<li><code><a title="wxcadm.CallQueue.config" href="#wxcadm.CallQueue.config">config</a></code></li>
<li><code><a title="wxcadm.CallQueue.enabled" href="#wxcadm.CallQueue.enabled">enabled</a></code></li>
<li><code><a title="wxcadm.CallQueue.extension" href="#wxcadm.CallQueue.extension">extension</a></code></li>
<li><code><a title="wxcadm.CallQueue.get_queue_config" href="#wxcadm.CallQueue.get_queue_config">get_queue_config</a></code></li>
<li><code><a title="wxcadm.CallQueue.get_queue_forwarding" href="#wxcadm.CallQueue.get_queue_forwarding">get_queue_forwarding</a></code></li>
<li><code><a title="wxcadm.CallQueue.id" href="#wxcadm.CallQueue.id">id</a></code></li>
<li><code><a title="wxcadm.CallQueue.location_id" href="#wxcadm.CallQueue.location_id">location_id</a></code></li>
<li><code><a title="wxcadm.CallQueue.name" href="#wxcadm.CallQueue.name">name</a></code></li>
<li><code><a title="wxcadm.CallQueue.phone_number" href="#wxcadm.CallQueue.phone_number">phone_number</a></code></li>
<li><code><a title="wxcadm.CallQueue.push" href="#wxcadm.CallQueue.push">push</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.Conference" href="#wxcadm.Conference">Conference</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.Conference.comment" href="#wxcadm.Conference.comment">comment</a></code></li>
<li><code><a title="wxcadm.Conference.deaf" href="#wxcadm.Conference.deaf">deaf</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.HuntGroup" href="#wxcadm.HuntGroup">HuntGroup</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.HuntGroup.agents" href="#wxcadm.HuntGroup.agents">agents</a></code></li>
<li><code><a title="wxcadm.HuntGroup.alternate_numbers_settings" href="#wxcadm.HuntGroup.alternate_numbers_settings">alternate_numbers_settings</a></code></li>
<li><code><a title="wxcadm.HuntGroup.call_policy" href="#wxcadm.HuntGroup.call_policy">call_policy</a></code></li>
<li><code><a title="wxcadm.HuntGroup.distinctive_ring" href="#wxcadm.HuntGroup.distinctive_ring">distinctive_ring</a></code></li>
<li><code><a title="wxcadm.HuntGroup.enabled" href="#wxcadm.HuntGroup.enabled">enabled</a></code></li>
<li><code><a title="wxcadm.HuntGroup.extension" href="#wxcadm.HuntGroup.extension">extension</a></code></li>
<li><code><a title="wxcadm.HuntGroup.first_name" href="#wxcadm.HuntGroup.first_name">first_name</a></code></li>
<li><code><a title="wxcadm.HuntGroup.get_config" href="#wxcadm.HuntGroup.get_config">get_config</a></code></li>
<li><code><a title="wxcadm.HuntGroup.id" href="#wxcadm.HuntGroup.id">id</a></code></li>
<li><code><a title="wxcadm.HuntGroup.language" href="#wxcadm.HuntGroup.language">language</a></code></li>
<li><code><a title="wxcadm.HuntGroup.language_code" href="#wxcadm.HuntGroup.language_code">language_code</a></code></li>
<li><code><a title="wxcadm.HuntGroup.last_name" href="#wxcadm.HuntGroup.last_name">last_name</a></code></li>
<li><code><a title="wxcadm.HuntGroup.location" href="#wxcadm.HuntGroup.location">location</a></code></li>
<li><code><a title="wxcadm.HuntGroup.name" href="#wxcadm.HuntGroup.name">name</a></code></li>
<li><code><a title="wxcadm.HuntGroup.phone_number" href="#wxcadm.HuntGroup.phone_number">phone_number</a></code></li>
<li><code><a title="wxcadm.HuntGroup.raw_config" href="#wxcadm.HuntGroup.raw_config">raw_config</a></code></li>
<li><code><a title="wxcadm.HuntGroup.time_zone" href="#wxcadm.HuntGroup.time_zone">time_zone</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.Location" href="#wxcadm.Location">Location</a></code></h4>
<ul class="two-column">
<li><code><a title="wxcadm.Location.address" href="#wxcadm.Location.address">address</a></code></li>
<li><code><a title="wxcadm.Location.available_numbers" href="#wxcadm.Location.available_numbers">available_numbers</a></code></li>
<li><code><a title="wxcadm.Location.call_queues" href="#wxcadm.Location.call_queues">call_queues</a></code></li>
<li><code><a title="wxcadm.Location.hunt_groups" href="#wxcadm.Location.hunt_groups">hunt_groups</a></code></li>
<li><code><a title="wxcadm.Location.id" href="#wxcadm.Location.id">id</a></code></li>
<li><code><a title="wxcadm.Location.name" href="#wxcadm.Location.name">name</a></code></li>
<li><code><a title="wxcadm.Location.spark_id" href="#wxcadm.Location.spark_id">spark_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.Org" href="#wxcadm.Org">Org</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.Org.call_queues" href="#wxcadm.Org.call_queues">call_queues</a></code></li>
<li><code><a title="wxcadm.Org.create_person" href="#wxcadm.Org.create_person">create_person</a></code></li>
<li><code><a title="wxcadm.Org.get_call_queues" href="#wxcadm.Org.get_call_queues">get_call_queues</a></code></li>
<li><code><a title="wxcadm.Org.get_hunt_groups" href="#wxcadm.Org.get_hunt_groups">get_hunt_groups</a></code></li>
<li><code><a title="wxcadm.Org.get_license_name" href="#wxcadm.Org.get_license_name">get_license_name</a></code></li>
<li><code><a title="wxcadm.Org.get_location_by_name" href="#wxcadm.Org.get_location_by_name">get_location_by_name</a></code></li>
<li><code><a title="wxcadm.Org.get_locations" href="#wxcadm.Org.get_locations">get_locations</a></code></li>
<li><code><a title="wxcadm.Org.get_people" href="#wxcadm.Org.get_people">get_people</a></code></li>
<li><code><a title="wxcadm.Org.get_person_by_email" href="#wxcadm.Org.get_person_by_email">get_person_by_email</a></code></li>
<li><code><a title="wxcadm.Org.get_person_by_id" href="#wxcadm.Org.get_person_by_id">get_person_by_id</a></code></li>
<li><code><a title="wxcadm.Org.get_pickup_groups" href="#wxcadm.Org.get_pickup_groups">get_pickup_groups</a></code></li>
<li><code><a title="wxcadm.Org.get_workspaces" href="#wxcadm.Org.get_workspaces">get_workspaces</a></code></li>
<li><code><a title="wxcadm.Org.get_wxc_people" href="#wxcadm.Org.get_wxc_people">get_wxc_people</a></code></li>
<li><code><a title="wxcadm.Org.get_wxc_person_license" href="#wxcadm.Org.get_wxc_person_license">get_wxc_person_license</a></code></li>
<li><code><a title="wxcadm.Org.get_xsi_endpoints" href="#wxcadm.Org.get_xsi_endpoints">get_xsi_endpoints</a></code></li>
<li><code><a title="wxcadm.Org.hunt_groups" href="#wxcadm.Org.hunt_groups">hunt_groups</a></code></li>
<li><code><a title="wxcadm.Org.id" href="#wxcadm.Org.id">id</a></code></li>
<li><code><a title="wxcadm.Org.licenses" href="#wxcadm.Org.licenses">licenses</a></code></li>
<li><code><a title="wxcadm.Org.locations" href="#wxcadm.Org.locations">locations</a></code></li>
<li><code><a title="wxcadm.Org.name" href="#wxcadm.Org.name">name</a></code></li>
<li><code><a title="wxcadm.Org.numbers" href="#wxcadm.Org.numbers">numbers</a></code></li>
<li><code><a title="wxcadm.Org.people" href="#wxcadm.Org.people">people</a></code></li>
<li><code><a title="wxcadm.Org.pickup_groups" href="#wxcadm.Org.pickup_groups">pickup_groups</a></code></li>
<li><code><a title="wxcadm.Org.workspace_locations" href="#wxcadm.Org.workspace_locations">workspace_locations</a></code></li>
<li><code><a title="wxcadm.Org.workspaces" href="#wxcadm.Org.workspaces">workspaces</a></code></li>
<li><code><a title="wxcadm.Org.xsi" href="#wxcadm.Org.xsi">xsi</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.Person" href="#wxcadm.Person">Person</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.Person.assign_wxc" href="#wxcadm.Person.assign_wxc">assign_wxc</a></code></li>
<li><code><a title="wxcadm.Person.barge_in" href="#wxcadm.Person.barge_in">barge_in</a></code></li>
<li><code><a title="wxcadm.Person.call_forwarding" href="#wxcadm.Person.call_forwarding">call_forwarding</a></code></li>
<li><code><a title="wxcadm.Person.call_queues" href="#wxcadm.Person.call_queues">call_queues</a></code></li>
<li><code><a title="wxcadm.Person.caller_id" href="#wxcadm.Person.caller_id">caller_id</a></code></li>
<li><code><a title="wxcadm.Person.calling_behavior" href="#wxcadm.Person.calling_behavior">calling_behavior</a></code></li>
<li><code><a title="wxcadm.Person.change_phone_number" href="#wxcadm.Person.change_phone_number">change_phone_number</a></code></li>
<li><code><a title="wxcadm.Person.disable_vm_to_email" href="#wxcadm.Person.disable_vm_to_email">disable_vm_to_email</a></code></li>
<li><code><a title="wxcadm.Person.display_name" href="#wxcadm.Person.display_name">display_name</a></code></li>
<li><code><a title="wxcadm.Person.dnd" href="#wxcadm.Person.dnd">dnd</a></code></li>
<li><code><a title="wxcadm.Person.email" href="#wxcadm.Person.email">email</a></code></li>
<li><code><a title="wxcadm.Person.enable_vm_to_email" href="#wxcadm.Person.enable_vm_to_email">enable_vm_to_email</a></code></li>
<li><code><a title="wxcadm.Person.extension" href="#wxcadm.Person.extension">extension</a></code></li>
<li><code><a title="wxcadm.Person.first_name" href="#wxcadm.Person.first_name">first_name</a></code></li>
<li><code><a title="wxcadm.Person.get_barge_in" href="#wxcadm.Person.get_barge_in">get_barge_in</a></code></li>
<li><code><a title="wxcadm.Person.get_call_forwarding" href="#wxcadm.Person.get_call_forwarding">get_call_forwarding</a></code></li>
<li><code><a title="wxcadm.Person.get_call_recording" href="#wxcadm.Person.get_call_recording">get_call_recording</a></code></li>
<li><code><a title="wxcadm.Person.get_caller_id" href="#wxcadm.Person.get_caller_id">get_caller_id</a></code></li>
<li><code><a title="wxcadm.Person.get_calling_behavior" href="#wxcadm.Person.get_calling_behavior">get_calling_behavior</a></code></li>
<li><code><a title="wxcadm.Person.get_dnd" href="#wxcadm.Person.get_dnd">get_dnd</a></code></li>
<li><code><a title="wxcadm.Person.get_full_config" href="#wxcadm.Person.get_full_config">get_full_config</a></code></li>
<li><code><a title="wxcadm.Person.get_intercept" href="#wxcadm.Person.get_intercept">get_intercept</a></code></li>
<li><code><a title="wxcadm.Person.get_vm_config" href="#wxcadm.Person.get_vm_config">get_vm_config</a></code></li>
<li><code><a title="wxcadm.Person.hunt_groups" href="#wxcadm.Person.hunt_groups">hunt_groups</a></code></li>
<li><code><a title="wxcadm.Person.id" href="#wxcadm.Person.id">id</a></code></li>
<li><code><a title="wxcadm.Person.intercept" href="#wxcadm.Person.intercept">intercept</a></code></li>
<li><code><a title="wxcadm.Person.last_name" href="#wxcadm.Person.last_name">last_name</a></code></li>
<li><code><a title="wxcadm.Person.license_details" href="#wxcadm.Person.license_details">license_details</a></code></li>
<li><code><a title="wxcadm.Person.licenses" href="#wxcadm.Person.licenses">licenses</a></code></li>
<li><code><a title="wxcadm.Person.location" href="#wxcadm.Person.location">location</a></code></li>
<li><code><a title="wxcadm.Person.numbers" href="#wxcadm.Person.numbers">numbers</a></code></li>
<li><code><a title="wxcadm.Person.push_vm_config" href="#wxcadm.Person.push_vm_config">push_vm_config</a></code></li>
<li><code><a title="wxcadm.Person.recording" href="#wxcadm.Person.recording">recording</a></code></li>
<li><code><a title="wxcadm.Person.refresh_person" href="#wxcadm.Person.refresh_person">refresh_person</a></code></li>
<li><code><a title="wxcadm.Person.reset_vm_pin" href="#wxcadm.Person.reset_vm_pin">reset_vm_pin</a></code></li>
<li><code><a title="wxcadm.Person.roles" href="#wxcadm.Person.roles">roles</a></code></li>
<li><code><a title="wxcadm.Person.set_calling_only" href="#wxcadm.Person.set_calling_only">set_calling_only</a></code></li>
<li><code><a title="wxcadm.Person.spark_id" href="#wxcadm.Person.spark_id">spark_id</a></code></li>
<li><code><a title="wxcadm.Person.start_xsi" href="#wxcadm.Person.start_xsi">start_xsi</a></code></li>
<li><code><a title="wxcadm.Person.update_person" href="#wxcadm.Person.update_person">update_person</a></code></li>
<li><code><a title="wxcadm.Person.vm_config" href="#wxcadm.Person.vm_config">vm_config</a></code></li>
<li><code><a title="wxcadm.Person.wxc" href="#wxcadm.Person.wxc">wxc</a></code></li>
<li><code><a title="wxcadm.Person.xsi" href="#wxcadm.Person.xsi">xsi</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.PickupGroup" href="#wxcadm.PickupGroup">PickupGroup</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.PickupGroup.get_config" href="#wxcadm.PickupGroup.get_config">get_config</a></code></li>
<li><code><a title="wxcadm.PickupGroup.id" href="#wxcadm.PickupGroup.id">id</a></code></li>
<li><code><a title="wxcadm.PickupGroup.location_id" href="#wxcadm.PickupGroup.location_id">location_id</a></code></li>
<li><code><a title="wxcadm.PickupGroup.name" href="#wxcadm.PickupGroup.name">name</a></code></li>
<li><code><a title="wxcadm.PickupGroup.users" href="#wxcadm.PickupGroup.users">users</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.Webex" href="#wxcadm.Webex">Webex</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.Webex.get_org_by_name" href="#wxcadm.Webex.get_org_by_name">get_org_by_name</a></code></li>
<li><code><a title="wxcadm.Webex.headers" href="#wxcadm.Webex.headers">headers</a></code></li>
<li><code><a title="wxcadm.Webex.orgs" href="#wxcadm.Webex.orgs">orgs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.Workspace" href="#wxcadm.Workspace">Workspace</a></code></h4>
<ul class="two-column">
<li><code><a title="wxcadm.Workspace.calendar" href="#wxcadm.Workspace.calendar">calendar</a></code></li>
<li><code><a title="wxcadm.Workspace.calling" href="#wxcadm.Workspace.calling">calling</a></code></li>
<li><code><a title="wxcadm.Workspace.capacity" href="#wxcadm.Workspace.capacity">capacity</a></code></li>
<li><code><a title="wxcadm.Workspace.created" href="#wxcadm.Workspace.created">created</a></code></li>
<li><code><a title="wxcadm.Workspace.floor" href="#wxcadm.Workspace.floor">floor</a></code></li>
<li><code><a title="wxcadm.Workspace.get_config" href="#wxcadm.Workspace.get_config">get_config</a></code></li>
<li><code><a title="wxcadm.Workspace.id" href="#wxcadm.Workspace.id">id</a></code></li>
<li><code><a title="wxcadm.Workspace.location" href="#wxcadm.Workspace.location">location</a></code></li>
<li><code><a title="wxcadm.Workspace.name" href="#wxcadm.Workspace.name">name</a></code></li>
<li><code><a title="wxcadm.Workspace.notes" href="#wxcadm.Workspace.notes">notes</a></code></li>
<li><code><a title="wxcadm.Workspace.sip_address" href="#wxcadm.Workspace.sip_address">sip_address</a></code></li>
<li><code><a title="wxcadm.Workspace.spark_id" href="#wxcadm.Workspace.spark_id">spark_id</a></code></li>
<li><code><a title="wxcadm.Workspace.type" href="#wxcadm.Workspace.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.WorkspaceLocation" href="#wxcadm.WorkspaceLocation">WorkspaceLocation</a></code></h4>
<ul class="two-column">
<li><code><a title="wxcadm.WorkspaceLocation.address" href="#wxcadm.WorkspaceLocation.address">address</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.city" href="#wxcadm.WorkspaceLocation.city">city</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.country" href="#wxcadm.WorkspaceLocation.country">country</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.get_config" href="#wxcadm.WorkspaceLocation.get_config">get_config</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.get_floors" href="#wxcadm.WorkspaceLocation.get_floors">get_floors</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.id" href="#wxcadm.WorkspaceLocation.id">id</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.latitude" href="#wxcadm.WorkspaceLocation.latitude">latitude</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.longitude" href="#wxcadm.WorkspaceLocation.longitude">longitude</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.name" href="#wxcadm.WorkspaceLocation.name">name</a></code></li>
<li><code><a title="wxcadm.WorkspaceLocation.notes" href="#wxcadm.WorkspaceLocation.notes">notes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wxcadm.WorkspaceLocationFloor" href="#wxcadm.WorkspaceLocationFloor">WorkspaceLocationFloor</a></code></h4>
</li>
<li>
<h4><code><a title="wxcadm.XSI" href="#wxcadm.XSI">XSI</a></code></h4>
<ul class="">
<li><code><a title="wxcadm.XSI.alternate_numbers" href="#wxcadm.XSI.alternate_numbers">alternate_numbers</a></code></li>
<li><code><a title="wxcadm.XSI.anonymous_call_rejection" href="#wxcadm.XSI.anonymous_call_rejection">anonymous_call_rejection</a></code></li>
<li><code><a title="wxcadm.XSI.calls" href="#wxcadm.XSI.calls">calls</a></code></li>
<li><code><a title="wxcadm.XSI.get_fac" href="#wxcadm.XSI.get_fac">get_fac</a></code></li>
<li><code><a title="wxcadm.XSI.get_services" href="#wxcadm.XSI.get_services">get_services</a></code></li>
<li><code><a title="wxcadm.XSI.monitoring" href="#wxcadm.XSI.monitoring">monitoring</a></code></li>
<li><code><a title="wxcadm.XSI.new_call" href="#wxcadm.XSI.new_call">new_call</a></code></li>
<li><code><a title="wxcadm.XSI.new_conference" href="#wxcadm.XSI.new_conference">new_conference</a></code></li>
<li><code><a title="wxcadm.XSI.profile" href="#wxcadm.XSI.profile">profile</a></code></li>
<li><code><a title="wxcadm.XSI.registrations" href="#wxcadm.XSI.registrations">registrations</a></code></li>
<li><code><a title="wxcadm.XSI.single_number_reach" href="#wxcadm.XSI.single_number_reach">single_number_reach</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>